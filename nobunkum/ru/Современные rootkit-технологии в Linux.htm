<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en"><head><script type="text/javascript" async="" src="%D0%A1%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20rootkit-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D0%B2%20Linux_files/ga.js"></script><script src="%D0%A1%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20rootkit-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D0%B2%20Linux_files/analytics.js" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app213.us.archive.org';v.server_ms=414;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="%D0%A1%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20rootkit-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D0%B2%20Linux_files/bundle-playback.js" charset="utf-8"></script>
<script type="text/javascript" src="%D0%A1%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20rootkit-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D0%B2%20Linux_files/wombat.js" charset="utf-8"></script>
<script>window.RufflePlayer=window.RufflePlayer||{};window.RufflePlayer.config={"autoplay":"on","unmuteOverlay":"hidden"};</script>
<script type="text/javascript" src="%D0%A1%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20rootkit-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D0%B2%20Linux_files/ruffle.js"></script>
<script type="text/javascript">
    __wm.pc(0.001);
    __wm.init("https://web.archive.org/web");
  __wm.wombat("http://nobunkum.ru:80/ru/linux-rootkits","20170621183459","https://web.archive.org/","web","https://web-static.archive.org/_static/",
	      "1498070099");
</script>
<link rel="stylesheet" type="text/css" href="%D0%A1%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20rootkit-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D0%B2%20Linux_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="%D0%A1%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20rootkit-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D0%B2%20Linux_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Современные rootkit-технологии в Linux</title>
  <!-- base href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/" -->
  <link rel="alternate" type="application/rss+xml" title="Журнал NO BUNKUM — Новости" href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/rss">
  <link rel="stylesheet" type="text/css" href="%D0%A1%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20rootkit-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D0%B2%20Linux_files/style.css">
<!--[if lt IE 8]>
<link rel="stylesheet" type="text/css" href="/template/css/ie.css" />
<![endif]-->
<!--[if IE 6]>
<link rel="stylesheet" type="text/css" href="/template/css/ie6.css" />
<![endif]-->
</head>
<body><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr;">
</div><div id="wm-ipp-print">The Wayback Machine - https://web.archive.org/web/20170621183459/http://nobunkum.ru:80/ru/linux-rootkits</div>
<script type="text/javascript">//<![CDATA[
__wm.bt(725,27,25,2,"web","http://nobunkum.ru/ru/linux-rootkits","20170621183459",1996,"https://web-static.archive.org/_static/",["https://web-static.archive.org/_static/css/banner-styles.css?v=S1zqJCYt","https://web-static.archive.org/_static/css/iconochive.css?v=qtvMKcIJ"], false);
  __wm.rw(1);
//]]></script>
<!-- END WAYBACK TOOLBAR INSERT -->
 
      <div class="subscribe">
        
<form action="/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits" method="post">
<div>
<input class="mail" type="text" name="email" placeholder="newsletter">
<input type="hidden" name="groups[]" value="1">
<input class="submit" type="submit" value="OK"></div>
</form>
      </div>
  <div id="header">
    <div id="title">
      <a id="logo" href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/"><img src="%D0%A1%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20rootkit-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D0%B2%20Linux_files/logo.jpg" width="374" height="51" alt="NO BUNKUM"></a>
      <p>...on guns, germs, and steel of the digital age</p>
    </div>
    <div id="subtitle">
      <ul><li class="first"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/lookout/" title="Lookout" class="issue">Lookout</a></li>
<li><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/analytics/" title="Analytics" class="issue">Analytics</a></li>
<li class="current"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/" title="NO BUNKUM" class="issue">NO BUNKUM</a></li>
<li class="last"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/demo/" title="Demo" class="issue">Demo</a></li>
</ul>
      <div class="headerlinks">
        <a id="headerlink-about" href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/about" title="О журнале"><span>?</span></a>
        <a id="headerlink-rss" href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/rss" title="RSS"><span>RSS</span></a>
      </div>
    </div>
  </div>
  <div id="content">
    <div class="aside-long" style="text-align:center;padding:15px 10px">
      <span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=Exploit.SWF.Agent.br">Exploit.SWF.Agent.br</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=Pdfka.asd">Pdfka.asd</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=Pidief.cvl">Pidief.cvl</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight2"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=TDSS">TDSS</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=TDSS+removal">TDSS removal</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=binary+planting">binary planting</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=bios+infection">bios infection</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=blind+sqli">blind sqli</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=bootkit">bootkit</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=bootkit+remover">bootkit remover</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=browser+exploitation">browser exploitation</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=com+hijacking">com hijacking</a></span>
<span class="tl-tag tl-tag-weight4"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=disassembling">disassembling</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=dll+hijacking">dll hijacking</a></span>
<span class="tl-tag tl-tag-weight2"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=drive-by+downloads">drive-by downloads</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=hack+online+banks">hack online banks</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=heap-spray">heap-spray</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=hijack+botnet">hijack botnet</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=ibank">ibank</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=kernel+protection">kernel protection</a></span>
<span class="tl-tag tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=kernel-mode+rootkit">kernel-mode rootkit</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=keylogger">keylogger</a></span>
<span class="tl-tag tl-tag-weight5"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=malware+analysis">malware analysis</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight2"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=rootkit+detection">rootkit detection</a></span>
<span class="tl-tag tl-tag-weight3"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=trojan">trojan</a></span>
<span class="tl-tag tl-tag-alt tl-tag-weight1"><a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/tags?tag=virus+removal">virus removal</a></span>
    </div>
    <div id="content_text" style="margin-top: -10px;">
<div id="content_title"><h1>Современные rootkit-технологии в Linux</h1></div>
<div id="article_author" class="author">Дмитрий Пукаленко<br><a href="https://web.archive.org/web/20170621183459/mailto:xdiman@gmail.com">xdiman@gmail.com</a></div><br>

<div style="padding-left: 14px;">
<a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#intro">Вступление</a><br>
<a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#user-mode">User-mode руткиты</a><br>
<a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#user-mode-ptrace">User-mode руткит: перехват действий с помощью ptrace()</a><br>
<a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#user-mode-ld_preload">User-mode руткит: LD_PRELOAD</a><br>
<a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#kernel-mode">Kernel-mode руткиты</a><br>
<a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#kernel-mode-syscall">Kernel-mode руткит: подмена системных вызовов</a><br>
<a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#kernel-mode-no_lkm">Kernel-mode руткит: обходимся без LKM</a><br>
<a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#outro">Резюме</a><br>
<a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#reference">Список литературы</a><br>
</div>

<h2 id="intro">Вступление</h2>

<p>Механизмы функционирования руткитов для Linux - интересная и мало 
освещенная тема. Rootkit-технологии используются для таких задач, как 
сокрытие действий атакующего, подмена выдачи браузера, прозрачное 
проксирование, балансировка нагрузки, защита системы от атак.</p> 

<p>Традиционно руткиты подразделяются на два больших класса: руткиты, 
работающие в пространстве пользователя (user-mode) и руткиты уровня ядра
 (kernel-mode). В данной статье я рассматриваю основные методы и нюансы 
реализации руткитов обоих типов.</p>

<h2 id="user-mode">User-mode руткиты</h2>

<p>Руткиты, работающие непосредственно в пространстве пользователя, 
стары как мир. Большинство из них функционируют за счет модификации 
утилит администрирования (ls, cat, ps, top, netstat и др.), 
обеспечивающей фильтрацию их вывода и сокрытие заданных файлов, 
настроек, сетевых подключений и другой системной информации. Ярким 
примером такого руткита является shv.</p>

<p>Подход, основанный на модификации исполняемых файлов, несет в себе 
массу недостатков. Во-первых, он не универсален: для обнаружения скрытых
 объектов достаточно воспользоваться утилитой, не входящей в стандартный
 набор администратора -  например, просмотреть содержимое каталога в 
Midnight Commander. Во-вторых, все современные IDS (например, Tripwire) 
периодически сверяют целостность бинарных файлов по размеру и 
контрольной сумме. Как следствие описанных недостатков, данный подход 
неприменим в современных системах. Рассмотрим его альтернативы.</p>


<h2 id="user-mode-ptrace">User-mode руткит: перехват вызовов с помощью ptrace()</h2>

<p>Система Linux предоставляет программисту широкие возможности для 
отладки приложений с помощью системного вызова ptrace(). Этот syscall 
позволяет получить практически полный контроль над сторонним процессом. 
Он имеет следующий прототип:</p>


<p>long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);</p>

<p>Первый параметр - команда отладчика, и назначение параметров addr и 
data меняется в зависимости от него. Для реализации руткита используются
 команды PTRACE_ATTACH, PTRACE_DETACH, PTRACE_GETREGS, PTRACE_SYSCALL, 
PTRACE_SETREGS, PTRACE_PEEKDATA, PTRACE_POKEDATA.</p>

<p>Рассмотрим вкратце логику работы руткита, основанного не перехвате ptrace().</p>

<p>1. Осуществляется перебор процессов, запущенных на данный момент в 
системе, и присоединение к ним, кроме проме процессов 0 и 1, руткита при
 помощи PTRACE_ATTACH. В дальнейшем можно присоединяться к новым 
процессам, отслеживая системный вызов fork(). Отлаживаемые процессы 
автоматически становятся потомками руткита.</p>
<p>2. Получение идентификатора какого-либо из потомков руткита, 
получившего сигнал отладчика SIGTRAP, посредством вызова waitpid(-1, 
&amp;status, WUNTRACED).</p>
<p>3. Анализ системного вызова. </p>

<p>В момент отладочного брейка процесс находится непосредственно перед 
выполнением системного вызова. При этом номер системного вызова 
находится в регистре eax - regs.orig_eax, а в regs.ebx, regs.ecx, 
regs.edx, regs.edi, regs.esi находятся остальные параметры. Для 
получения значений регистров вызываем ptrace с параметром 
PTRACE_GETREGS. При этом в параметр data загружается адрес структуры 
user_regs_struct, хранящейся в &lt;sys/user.h&gt;. </p>

<p>Как фильтровать системные вызовы? Для сокрытия процессов и файлов 
необходимо обрабатывать те вызовы, в которых значение regs.orig_eax 
соответствует константе __NR_getdents (__NR_getdents64). Для подмены 
содержимого файлов - __NR_read, __NR_write, и т.д. Полный список 
системных вызовов доступен в &lt;asm/unistd.h&gt;. Контроль всех сетевых
 вызовов на 32-битной архитектуре  обеспечивается перехватом 
единственного системного вызова __NR_socketcall, при этом номер 
конкретной функции находится в regs.ebx (полный список номеров функций 
находится в &lt;linux/net.h&gt;). На 64-битных архитектурах за каждую 
сетевую процедуру отвечает отдельный системный вызов. </p>

<p>Если перехваченный вызов нам интересен, можно приступить к анализу 
аргументов. Вызываем ptrace с параметром PTRACE_PEEKDATA. При этом в 
параметре addr должен находиться реальный адрес в пространстве 
отлаживаемого процесса. Функция вернет 32-битное число (на 32-битных 
архитектурах), поэтому для получения полного содержимого анализируемого 
параметра нужно повторять в цикле процедуру вызова функции 
ptrace(..PTRACE_PEEKDATA..), постепенно увеличивая addr, необходимое 
число раз или до достижения нулевого байта, если речь идет о строке. 
После анализа и совершения необходимых приготовлений (например, 
сохранения адресов параметров и т.п.), можно переходить к следующему 
пункту.</p>

<p>4. Завершаем системный вызов: ptrace(..PTRACE_SYSCALL..), и ожидаем 
его результат: waitpid(pid, &amp;status, WUNTRACED). После чего снова 
вызываем ptrace(..PTRACE_GETREGS..) для получения контекста 
отлаживаемого процесса. В regs.eax будет получен результат системного 
вызова, который можно изменять - например, вернуть измененное количество
 прочитанных байт (для функции read()). Запись значений регистров 
обратно в пользовательский контекст выполняется с помощью 
PTRACE_SETREGS, с указанием в параметре data адреса структуры с 
измененными регистрами. </p>

<p>Далее - анализ и изменение параметров. Модификация памяти процесса 
выполняется с помощью PTRACE_POKEDATA, при этом в качестве параметра 
addr указывается адрес в пространстве процесса, в качестве параметра 
data - значение (обратите внимание: значение, а не адрес!) для записи по
 данному адресу. Постепенно инкрементируя addr, запишем необходимые 
данные в пространство процесса.</p>

<p>5. Выполняем инструкцию PTRACE_SYSCALL и возвращаем процессу 
управление, после чего ожидаем очередного сигнала от процесса-потомка 
при помощи waitpid(-1, &amp;status, WUNTRACED).</p>

<p>Это базовый алгоритм ptrace-руткита, не учитывающий нюансов 
реализации. Рассмотрим основные проблемы и подводные камни, возникающие в
 процессе разработки.</p>

<p>Выделение памяти в адресном пространстве чужих процессов. Для этого 
можно применить грязный хак, заключающийся в следующем. На этапе 
инициализации процесс часто совершает системный вызов mmap2() для 
постраничного выделения памяти и munmap - для освобождения. Перехватив 
mmap2, можно модифицировать параметр, хранящийся в regs.edx: добавить 
туда PROT_WRITE|PROT_EXEC, и при необходимости увеличить размер 
запрашиваемой памяти. Когда же процесс вызовет munmap - можно 
модифицировать второй параметр вызова, выставив его равным 0, или даже 
подменить регистры так, чтобы была вызвана функция brk(), что приведет к
 выделению дополнительной памяти. Теперь у нас есть блок памяти в 
адресном пространстве процесса, который можно использовать для своих 
нужд.</p>

<p>Выполнение произвольного кода в контексте процесса. Для этого можно 
скопировать необходимый код в память процесса, полученную вышеописанным 
методом, сохранить контекст текущего процесса (при помощи 
PTRACE_PEEKUSER и PTRACE_POKEUSER, см. &lt;sys/user.h&gt;), изменить eip
 и исполнить записанный код пошагово, с помощью параметра 
PTRACE_SINGLESTEP, после чего восстановить сохраненный контекст.</p>

<p>Есть еще один интересный момент, связанный с сокрытием объектов в 
системе. Если администратор системы, в которой установлен руткит, 
попытается отладить какую-либо программу с помощью gdb или просто 
протрассировать ее при помощи strace, он получит -EPERM (Operation not 
permitted), что выдаст присутствие руткита. Для предотвращения такой 
возможности можно перехватывать сам системный вызов ptrace, делать 
PTRACE_DETACH, и помещать pid отлаживаемого процесса и pid отладчика в 
очередь до тех пор, пока отладчик повторно не вызовет ptrace с 
параметром PTRACE_DETACH. После чего можно снова присоединяться к 
процессу и продолжать контролировать его выполнение.</p>

<h2 id="user-mode-ld_preload">User-mode руткит: LD_PRELOAD</h2>

<p>Переменная окружения LD_PRELOAD позволяет подгрузить свою библиотеку и
 подменить адреса библиотечных процедур, используемых в программе. 
Данную особенность системы также можно использовать с целью сокрытия тех
 или иных объектов. Недостаток этого метода в том, что перехватываются 
библиотечные функции, используемые программой, поэтому он узко 
специфичен. Но есть плюсы - например, перехватив SSL_read и SSL_write, 
можно читать и модифицировать незашифрованный трафик в обход 
SSL-шифрования!</p>

<p>Для использования данного метода переопределим в нашей .so библиотеке
 те функции, которые необходимо перехватывать, и обеспечим вызов 
оригинальной функции посредством ее динамической подгрузки из настоящей 
библиотеки с помощью dlopen/dlsym. Скомпилировав библиотеку, пропишем ее
 отдельной строкой в /etc/ld.so.preload, в результате чего все 
запускаемые впоследствии процессы будут работать с переопределенной 
функцией. </p>

<p>Что делать, если программа получает адреса функций динамически? В 
таком случае можно перехватывать вызовы dlopen и dlsym, и при совпадении
 параметров dlsym с перехватываемой функцией указывать адрес подставной 
процедуры. </p>

<p>Поскольку практически все программы используют функцию readdir для 
чтения элементов директории, ничто не мешает скрывать файлы и процессы, 
равно как и сам файл /etc/ld.so.preload.</p>

<h2 id="kernel-mode">Kernel-mode руткиты</h2>

<p>User-mode руткиты обладают существенным недостатком: их очень легко 
обнаружить из режима ядра. При этом работа руткита в режиме ядра, 
напротив, предоставляет неограниченные возможности для манипуляции 
системой и оборудованием. </p>

<p>Самый распространенный метод, обеспечивающий функционирование руткита
 уровня ядра - это перехват системных вызовов путем подмены 
соответствующей записи в таблице системных вызовов sys_call_table. 
Детали этого метода заключаются в следующем. При обработке прерывания 
int 0x80 (или инструкции sysenter) управление передается обработчику 
системных вызовов, который после предварительных процедур передает 
управление на адрес, записанный по смещению %eax в sys_call_table. Таким
 образом, подменив адрес в таблице, мы получаем контроль над системным 
вызовом. Этот метод имеет свои недостатки: в частности, он легко 
детектируется антируткитами; таблица вызовов в современных ядрах не 
экспортируется; и кроме того, перехват некоторых системных вызовов 
(например, execve()) нетривиален. </p>

<p>Другим распространенным механизмом в kernel-mode руткитах является 
патчинг VFS (Virtual Filesystem Switch). Этот подход применяется в 
рутките adore-ng. Он основан на подмене адреса какой-либо из 
функций-обработчиков для текущей файловой системы. </p>

<p>Как и в Windows, широко используется сплайсинг - замена первых байтов
 кода системного вызова на инструкцию jmp, осуществляющую переход на 
адрес обработчика руткита. В коде перехвата обеспечивается выполнение 
проверок, возврат байтов, вызов оригинального кода системного вызова и 
повторная установка перехвата. Данный метод также легко детектируется. </p>

<p>Еще один метод - подмена самого обработчика прерываний в IDT.</p>

<p>Рассмотрим некоторые методы реализации kernel-mode руткита более подробно.</p>

<h2 id="kernel-mode-syscall">Kernel-mode руткит: подмена системных вызовов</h2>

<p>Краеугольный камень этого метода - поиск адреса таблицы системных 
вызовов sys_call_table. Как уже упоминалось выше, в ядрах версии 2.6 
таблица не экспортируется. </p>

<p>Первый способ решения этой проблемы - поиск таблицы в /proc/kallsyms. </p>

<p># cat /proc/kallsyms | grep sys_call_table<br>
c03596e0 R sys_call_table
</p>

<p>Если администратор системы отключил kallsyms,  то этот метод не сработает. </p>

<p>Существует также метод, основанный на поиске известного нам адреса 
sys_close там, где, предположительно, может находиться таблица. <a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#reference">[1]</a></p>

<pre style="font-size:80%">unsigned long *ptr;
unsigned long arr[4];
int i;
ptr = (unsigned long *)((init_mm.end_code + 4) &amp; 0xfffffffc);

while((unsigned long)ptr &lt; (unsigned long)init_mm.end_data)
{
   if (*ptr == (unsigned long *)sys_close)
   {
      for (i = 0; i &lt; 4; i++)
      {
         arr[i] = *(ptr + i);
         arr[i] = (arr[i] &gt;&gt; 16) &amp; 0x0000ffff;
      }
      
      if (arr[0] != arr[2] || arr[1] != arr[3])
      {
         sys_call_table = (ptr - __NR_close);
         break;
      }
   }
   
   ptr++;
}

printk(KERN_INFO "sys_call_table base found at: %x\n", sys_call_table);
</pre>

<p>Этот метод не дает стопроцентной гарантии обнаружения таблицы системных вызовов.</p>

<p>Зная, что реализация обработчика системных вызовов не менялась уже давно, мы можем использовать следующий алгоритм:</p>

<ul>
<li> получить адрес IDT;
</li><li> получить адрес обработчика прерывания 0x80;
</li><li> начать искать с этого адреса инструкцию call: там и будет искомый адрес таблицы.
</li></ul>

<p>Код должен получиться примерно таким: <a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#reference">[2]</a></p>

<pre style="font-size:80%;">main()
{
    unsigned sys_call_off;
    unsigned sct;
    char sc_asm[CALLOFF], *p;

    /* well let's read IDTR */
    asm("sidt %0" : "=m" (idtr));
    printf("idtr base at 0x%X\n", (int)idtr.base);

    /* now we will open kmem */
    kmem = open("/dev/kmem", O_RDONLY);
    if (kmem &lt; 0) return 1;

    /* read-in IDT for 0x80 vector (syscall) */
    readkmem(&amp;idt, idtr.base + 8 * 0x80, sizeof(idt));
    sys_call_off = (idt.off2 &lt;&lt; 16) | idt.off1;
    printf("idt80: flags=%X sel=%X off=%X\n",
            (unsigned)idt.flags, (unsigned)idt.sel, sys_call_off);

    /* we have syscall routine address now, 
       look for syscall tabledispatch (indirect call) */
    readkmem(sc_asm, sys_call_off, CALLOFF);
    p = (char *)memmem(sc_asm, CALLOFF, "\xff\x14\x85", 3);
    sct = *(unsigned *)(p + 3);
    
    if (p) 
    {
        printf("sys_call_table at 0x%x, call dispatch at 0x%x\n", sct, p);
    }
    
    close(kmem);
}
</pre>

<p>Этот код ориентирован на работу с памятью ядра из адресного 
пространства пользователя, однако может быть легко модифицирован для 
работы в режиме ядра. На сегодняшний день он является самым 
универсальным и надежным методом поиска таблицы системных вызовов.</p>

<p>Еще одна проблема метода перехвата системных вызовов заключается в 
невозможности перехватить execve() для контроля над создаваемыми 
процессами. Для ее решения можно использовать грязный хак: поиск 
свободного слота в sys_call_table, запись туда старого адреса execve(), 
перехват, и последующие вызовы через int 0x80.</p>

<p>Антируткиты, основанные на контроле целостности таблицы, обходятся 
простым поиском в пространстве ядра сохраненной копии таблицы и 
последующим ее изменением.</p>

<h2 id="kernel-mode-no_lkm">Kernel-mode руткит: обходимся без LKM</h2>

<p>Возможность загрузки дополнительных модулей в ядро может быть 
отключена при его сборке. В таких случаях используется патчинг ядра "на 
лету", подробно описанный в статье Phrack #58, Linux on-the-fly kernel 
patching without LKM[<a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#reference">3</a>]. Рассмотрим здесь основные принципы этого метода.</p>

<p>Во-первых, производится поиск таблицы системных вызовов. После этого 
необходимо найти адрес kmalloc для выделения памяти в пространстве ядра.
 Лучше всего это сделать через kmalloc, но в крайнем случае можно 
воспользоваться ненадежным методом брутфорса, основанным на поиске самой
 часто вызываемой функции со вторым параметром GFP_KERNEL. Для примера 
приведен код из статьи[<a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/linux-rootkits#reference">3</a>], модифицированный для ядер 2.6.х:</p>

<pre style="font-size:80%">unsigned long get_kma(int kmem, ulong pgoff)
{
    struct { uint a, f, cnt; } rtab[RNUM], *t;
    unsigned int i, a, j, push1, push2;
    unsigned int found = 0, total = 0;
    unsigned char buf[0x10010], kcache[10], *p;
    unsigned long ret;
    unsigned long gfp;
    unsigned long eax;
    unsigned long cnt = 0;

    // get kernel symbol directly via get_kernel_syms
    ret = get_sym("kmalloc");
    if (ret) return ret;

    // determine GFP_KERNEL value, varying on kernel version
    gfp = get_gfp();

    // try to bruteforce kmalloc address ;)
    for (i = (pgoff + 0x100000); i &lt; (pgoff + 0x1000000); i+= 0x10000)
    {
        // read data from kernel memory
        if (!readkmem(kmem, buf, i, sizeof(buf))) return 0;

        // look for mov GFP_KERNEL, edx and call
        for (p = buf; p &lt; buf + 0x10000;)
        {
            // look at opcode
            switch (*p++)
            {
            case 0xa1:
                // probably, mov to eax
                // so let's store eax value to variable
                // kmalloc probably does not take very big args
                eax = *(unsigned *)p;
                continue;

            case 0xba:                    
                // mov found, check for GFP_KERNEL
                if (!memmem(p, 4, &amp;gfp, 4)) continue;
                push1 = *(unsigned *)p;
                p += 4;
                continue;

            case 0xe8:
                // call found, if mov was saved then break
                if (push1) break;

            default:
                // some other shit
                if (push1 &amp;&amp; cnt &lt; 0)
                {
                    cnt++;
                    continue;
                }
                else 
                { 
                    cnt = 0;
                }
                    
                push1 = 0;
                continue;
            }

            // we have mov and call instructions, let's get address
            // and check if it is in kernel code section
            a = *(unsigned *) p + i + (p - buf) + 4;
            if ((a &amp; 0xF0000000) != pgoff) continue;

            // kmem_page_alloc test
            // very very bad and platform-dependent
            if (readkmem(kmem, kcache, a, 4))
            {
                if (memmem(kcache, 4, "\x57\xf6\xc2\x10", 4)) continue;
            }    

#ifdef DEBUG            
            printf("%x %0.2x %0.2x %0.2x %0.2x eax=0x%x\n",
                i + (p - buf), 
                ((unsigned char*)&amp;a)[0], 
                ((unsigned char*)&amp;a)[1], 
                ((unsigned char*)&amp;a)[2], 
                ((unsigned char*)&amp;a)[3], 
                eax);
#endif
            p += 4;
            total++;

            // find address in table
            for (j = 0, t = rtab; j &lt; found; j++, t++) 
            {
                if (t-&gt;a == a &amp;&amp; t-&gt;f == push1) break;
            }
            
            if (j &lt; found) 
            {
                t-&gt;cnt++;
            }
            else if (found &gt;= RNUM)
            {
                return 0;
            }
            else
            {
                found++;
                t-&gt;a = a;
                t-&gt;f = push1;
                t-&gt;cnt = 1;
            }
        
            push1 = push2 = 0;
        } 
    }

    t = NULL;
    
    // find function called maximum number of times
    for (j = 0; j &lt; found; j++) 
    {
        if (!t || rtab[j].cnt &gt; t-&gt;cnt) t = rtab + j;
    }
    
    if (t) return t-&gt;a;

    return 0;
}

</pre>

<p>При использовании этого кода следует учитывать, что значение GFP_KERNEL различно в разных версиях ядра. </p>

<p>После определения адресов можно временно заменить какой-либо 
системный вызов (например, olduname()) своим кодом с прошитым в нем 
адресом kmalloc для выделения необходимой памяти, в которую впоследствии
 будет скопирован код новых системных вызовов. После успешного 
выполнения этой процедуры и копирования кода новых системных вызовов в 
ядро производится подмена значений в sys_call_table в соответствии со 
стандартным алгоритмом. </p>

<h2 id="outro">Резюме</h2>

<p>В этой статье рассмотрены основные технологии, применяемые в 
современных ring3 и ring0 руткитах для Linux. Некоторые методы остались 
за пределами статьи: например, патчинг VFS и смена обработчика 
прерываний - о них будет рассказано в следующей статье.</p>

<h2 id="reference">Список литературы</h2>

<p>[1] dev0id, <a href="https://web.archive.org/web/20170621183459/http://www.securitylab.ru/contest/212111.php">"Защита от исполнения в стеке (ОС Линукс)"</a> <br>
[2] Phrack #58, <a href="https://web.archive.org/web/20170621183459/http://www.phrack.org/issues.html?issue=58&amp;id=7#article">"Linux on-the-fly kernel patching without LKM"</a></p>

<p class="author" style="padding-left: 0px;">Last updated: 17.03.2012</p>

</div>
  ﻿</div>
  <div id="footer">
    <p class="copyright">© 2009–2012 <a href="https://web.archive.org/web/20170621183459/http://www.nobunkum.ru/">NOBUNKUM</a> by <a href="https://web.archive.org/web/20170621183459/http://www.esagelab.ru/">Esage Lab</a> &nbsp;&nbsp;&nbsp;&nbsp;<a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/ru/">/на русском языке</a> <a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/about">/about</a> <a href="https://web.archive.org/web/20170621183459/http://nobunkum.ru/rss">/rss</a></p>
  </div>
  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3546318-9']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://web.archive.org/web/20170621183459/https://ssl' : 'https://web.archive.org/web/20170621183459/http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</body></html>
<!--
     FILE ARCHIVED ON 18:34:59 Jun 21, 2017 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 12:23:04 May 30, 2024.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 0.685
  exclusion.robots: 0.181
  exclusion.robots.policy: 0.169
  esindex: 0.013
  cdx.remote: 5.216
  LoadShardBlock: 168.422 (3)
  PetaboxLoader3.datanode: 202.0 (4)
  load_resource: 210.639
  PetaboxLoader3.resolve: 162.301
-->